var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"generated/kelvin_helmholtz/#Kelvin-Helmholtz-instability","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"This example simulates a simple 2D Kelvin-Helmholtz instability and is based on the similar Oceananigans example.\n\nBefore starting, make sure you have the required packages installed for this example, which can be done with\n\nusing Pkg\npkg\"add Oceananigans, Oceanostics, CairoMakie, Rasters\"","category":"section"},{"location":"generated/kelvin_helmholtz/#Model-and-simulation-setup","page":"Kelvin-Helmholtz instability","title":"Model and simulation setup","text":"We begin by creating a model with an isotropic diffusivity and fifth-order advection on a xz 128Â² grid using a buoyancy b as the active scalar. We'll work here with nondimensional quantities.\n\nusing Oceananigans\n\nN = 128\nL = 10\ngrid = RectilinearGrid(size=(N, N), x=(-L/2, +L/2), z=(-L/2, +L/2), topology=(Periodic, Flat, Bounded))\n\nmodel = NonhydrostaticModel(grid; timestepper = :RungeKutta3,\n                            advection = UpwindBiased(order=5),\n                            closure = ScalarDiffusivity(Î½=2e-5, Îº=2e-5),\n                            buoyancy = BuoyancyTracer(), tracers = :b)\n\nWe use hyperbolic tangent functions for the initial conditions and set the maximum Richardson number below the threshold of 1/4. We also add some grid-scale small-amplitude noise to u to kick the instability off:\n\nnoise(x, z) = 2e-2 * randn()\nshear_flow(x, z) = tanh(z) + noise(x, z)\n\nRiâ‚€ = 0.1; h = 1/4\nstratification(x, z) = h * Riâ‚€ * tanh(z / h)\n\nset!(model, u=shear_flow, b=stratification)\n\nNext create an adaptive-time-step simulation using the model above:\n\nsimulation = Simulation(model, Î”t=0.1, stop_time=100)\n\nwizard = TimeStepWizard(cfl=0.8, max_Î”t=1)\nsimulation.callbacks[:wizard] = Callback(wizard, IterationInterval(2))","category":"section"},{"location":"generated/kelvin_helmholtz/#Model-diagnostics","page":"Kelvin-Helmholtz instability","title":"Model diagnostics","text":"We set-up a progress messenger using the TimedMessenger, which displays, among other information, the time step duration\n\nusing Oceanostics\n\nprogress = ProgressMessengers.TimedMessenger()\nsimulation.callbacks[:progress] = Callback(progress, IterationInterval(200))\n\nWe can also define some useful diagnostics for of the flow, starting with the RichardsonNumber\n\nRi = RichardsonNumber(model)\n\nWe also set-up the QVelocityGradientTensorInvariant, which is usually used for visualizing vortices in the flow:\n\nQ = QVelocityGradientTensorInvariant(model)\n\nQ is one of the velocity gradient tensor invariants and it measures the amount of vorticity versus the strain in the flow and, when it's positive, indicates a vortex. This method of vortex visualization is called the Q-criterion.\n\nLet's also keep track of the amount of buoyancy mixing by measuring the buoyancy variance dissipation rate and diffusive term. When volume-integrated, these two quantities should be equal.\n\nâˆ«Ï‡á´° = Integral(TracerVarianceEquation.DissipationRate(model, :b))\nâˆ«Ï‡ = Integral(TracerVarianceEquation.Diffusion(model, :b))\n\nNow we write these quantities, along with b, to a NetCDF:\n\noutput_fields = (; Ri, Q, model.tracers.b, âˆ«Ï‡, âˆ«Ï‡á´°)\n\nusing NCDatasets\nfilename = \"kelvin_helmholtz\"\nsimulation.output_writers[:nc] = NetCDFWriter(model, output_fields,\n                                              filename = joinpath(@__DIR__, filename),\n                                              schedule = TimeInterval(1),\n                                              overwrite_existing = true)","category":"section"},{"location":"generated/kelvin_helmholtz/#Run-the-simulation-and-process-results","page":"Kelvin-Helmholtz instability","title":"Run the simulation and process results","text":"To run the simulation:\n\nrun!(simulation)\n\nNow we'll read the results using Rasters.jl, which works somewhat similarly to Python's Xarray and can speed-up the work the workflow\n\nusing Rasters\n\nds = RasterStack(simulation.output_writers[:nc].filepath)\n\nWe now use Makie to create the figure and its axes\n\nusing CairoMakie\n\nset_theme!(Theme(fontsize = 24))\nfig = Figure()\n\nkwargs = (xlabel=\"x\", ylabel=\"z\", height=150, width=250)\nax1 = Axis(fig[2, 1]; title = \"Ri\", kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Q\", kwargs...)\nax3 = Axis(fig[2, 3]; title = \"b\", kwargs...);\nnothing #hide\n\nNext we use Observables to lift the values and plot heatmaps and their colorbars\n\nn = Observable(1)\n\nRiâ‚™ = @lift set(ds.Ri[Ti=$n, y_aca=Near(0)], :x_caa => X, :z_aaf => Z)\nhm1 = heatmap!(ax1, Riâ‚™; colormap = :bwr, colorrange = (-1, +1))\nColorbar(fig[3, 1], hm1, vertical=false, height=8)\n\nQâ‚™ = @lift set(ds.Q[Ti=$n, y_aca=Near(0)], :x_caa => X, :z_aac => Z)\nhm2 = heatmap!(ax2, Qâ‚™; colormap = :inferno, colorrange = (0, 0.2))\nColorbar(fig[3, 2], hm2, vertical=false, height=8)\n\nbâ‚™ = @lift set(ds.b[Ti=$n, y_aca=Near(0)], :x_caa => X, :z_aac => Z)\nhm3 = heatmap!(ax3, bâ‚™; colormap = :balance, colorrange = (-2.5e-2, +2.5e-2))\nColorbar(fig[3, 3], hm3, vertical=false, height=8);\nnothing #hide\n\nWe now plot the time evolution of our integrated quantities\n\naxb = Axis(fig[4, 1:3]; xlabel=\"Time\", height=100)\ntimes = dims(ds, :Ti)\nlines!(axb, Array(times), Array(ds.âˆ«Ï‡),  label = \"âˆ«Ï‡dV\")\nlines!(axb, Array(times), Array(ds.âˆ«Ï‡á´°), label = \"âˆ«Ï‡á´°dV\", linestyle=:dash)\naxislegend(position=:lb, labelsize=14)\n\nNow we mark the time by placing a vertical line in the bottom panel and adding a helpful title\n\ntâ‚™ = @lift times[$n]\nvlines!(axb, tâ‚™, color=:black, linestyle=:dash)\n\ntitle = @lift \"Time = \" * string(round(times[$n], digits=2))\nfig[1, 1:3] = Label(fig, title, fontsize=24, tellwidth=false);\nnothing #hide\n\nFinally, we adjust the figure dimensions to fit all the panels and record a movie\n\nresize_to_layout!(fig)\n\n@info \"Animating...\"\nrecord(fig, filename * \".mp4\", 1:length(times), framerate=10) do i\n       n[] = i\nend\n\n(Image: )\n\nSimilarly to the kinetic energy dissipation rate (see the Two-dimensional turbulence example), TracerVarianceDissipationRate and TracerVarianceDiffusion are implemented with a energy-conserving formulation, which means that (for NoFlux boundary conditions) their volume-integral should be exactly (up to machine precision) the same.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/#Tilted-bottom-boundary-layer-example","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer example","text":"This example is based on the similar Oceananigans example and simulates a two-dimensional oceanic bottom boundary layer in a domain that's tilted with respect to gravity. We simulate the perturbation away from a constant along-slope (y-direction) velocity constant density stratification.  This perturbation develops into a turbulent bottom boundary layer due to momentum loss at the bottom boundary.\n\nFirst let's make sure we have all required packages installed.\n\nusing Pkg\npkg\"add Oceananigans, Oceanostics, Rasters, CairoMakie\"","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/#Grid","page":"Tilted bottom boundary layer","title":"Grid","text":"We start by creating a x z grid with 64Â² cells and finer resolution near the bottom:\n\nusing Oceananigans\nusing Oceananigans.Units\n\nLx = 200meters\nLz = 100meters\nNx = 64\nNz = 64\n\nrefinement = 1.8 # controls spacing near surface (higher means finer spaced)\nstretching = 10  # controls rate of stretching at bottom\n\nh(k) = (Nz + 1 - k) / Nz\nÎ¶(k) = 1 + (h(k) - 1) / refinement\nÎ£(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching))\nz_faces(k) = - Lz * (Î¶(k) * Î£(k) - 1)\n\ngrid = RectilinearGrid(topology = (Periodic, Flat, Bounded), size = (Nx, Nz),\n                       x = (0, Lx), z = z_faces)\n\nNote that, with the z faces defined as above, the spacings near the bottom are approximately constant, becoming progressively coarser moving up.","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/#Tilting-the-domain","page":"Tilted bottom boundary layer","title":"Tilting the domain","text":"We use a domain that's tilted with respect to gravity by\n\nÎ¸ = 5; # degrees\nnothing #hide\n\nso that x is the along-slope direction, z is the across-sloce direction that is perpendicular to the bottom, and the unit vector anti-aligned with gravity is\n\ngÌ‚ = [sind(Î¸), 0, cosd(Î¸)]\n\nChanging the vertical direction impacts both the gravity_unit_vector for Buoyancy as well as the rotation_axis for Coriolis forces,\n\nbuoyancy = BuoyancyForce(BuoyancyTracer(), gravity_unit_vector = -gÌ‚)\n\nfâ‚€ = 1e-4/second\ncoriolis = ConstantCartesianCoriolis(f = fâ‚€, rotation_axis = gÌ‚)\n\nThe tilting also affects the kind of density stratified flows we can model. The simulate an environment that's uniformly stratified, with a stratification frequency\n\nNÂ² = 1e-5/second^2;\nnothing #hide\n\nIn a tilted coordinate, this can be achieved with\n\n@inline constant_stratification(x, z, t, p) = p.NÂ² * (x * p.gÌ‚[1] + z * p.gÌ‚[3]);\nnothing #hide\n\nHowever, this distribution is not periodic in x and can't be explicitly modelled on an x-periodic grid such as the one used here. Instead, we simulate periodic perturbations away from the constant density stratification by imposing a constant stratification as a BackgroundField,\n\nB_field = BackgroundField(constant_stratification, parameters=(; gÌ‚, NÂ²))","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/#Bottom-drag","page":"Tilted bottom boundary layer","title":"Bottom drag","text":"We impose bottom drag that follows Monin-Obukhov theory and include the background flow in the drag calculation, which is the only effect the background flow has on the problem\n\nVâˆž = 0.1meters/second\nzâ‚€ = 0.1meters # (roughness length)\nÎº = 0.4 # von Karman constant\nzâ‚ = znodes(grid, Center())[1] # Closest grid center to the bottom\ncá´° = (Îº / log(zâ‚ / zâ‚€))^2 # Drag coefficient\n\n@inline drag_u(x, t, u, v, p) = - p.cá´° * âˆš(u^2 + (v + p.Vâˆž)^2) * u\n@inline drag_v(x, t, u, v, p) = - p.cá´° * âˆš(u^2 + (v + p.Vâˆž)^2) * (v + p.Vâˆž)\n\ndrag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cá´°, Vâˆž))\ndrag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cá´°, Vâˆž))\n\nu_bcs = FieldBoundaryConditions(bottom = drag_bc_u)\nv_bcs = FieldBoundaryConditions(bottom = drag_bc_v)","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/#Create-model-and-simulation","page":"Tilted bottom boundary layer","title":"Create model and simulation","text":"We are now ready to create the model. We create a NonhydrostaticModel with a 5th UpwindBiased advection scheme, a RungeKutta3 timestepper, and a constant viscosity and diffusivity.\n\nclosure = ScalarDiffusivity(Î½=2e-4, Îº=2e-4)\n\nmodel = NonhydrostaticModel(grid; buoyancy, coriolis, closure,\n                            timestepper = :RungeKutta3,\n                            advection = UpwindBiased(order=5),\n                            tracers = :b,\n                            boundary_conditions = (u=u_bcs, v=v_bcs),\n                            background_fields = (; b=B_field))\n\nnoise(x, z) = 1e-3 * randn() * exp(-(10z)^2/grid.Lz^2)\nset!(model, u=noise, w=noise)\n\nThe bottom-intensified noise above should accelerate the emergence of turbulence close to the wall.\n\nWe are now ready to create the simulation. We begin by setting the initial time step conservatively, based on the smallest grid size of our domain and set-up a\n\nusing Oceananigans.Units\n\nsimulation = Simulation(model, Î”t = 0.5 * minimum_zspacing(grid) / Vâˆž, stop_time = 12hours)\n\nWe use TimeStepWizard to maximize Î”t\n\nwizard = TimeStepWizard(max_change=1.1, cfl=0.7)\nsimulation.callbacks[:wizard] = Callback(wizard, IterationInterval(4))","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/#Model-diagnostics","page":"Tilted bottom boundary layer","title":"Model diagnostics","text":"We set-up a custom progress messenger using Oceanostics.ProgressMessengers, which allows us to combine different ProgressMessengers into one:\n\nusing Oceanostics.ProgressMessengers\n\nwalltime_per_timestep = StepDuration() # This needs to instantiated here, and not in the function below\nprogress(simulation) = @info (PercentageProgress(with_prefix=false, with_units=false) + SimulationTime() + TimeStep() + MaxVelocities() + AdvectiveCFLNumber() + walltime_per_timestep)(simulation)\n\nsimulation.callbacks[:progress] = Callback(progress, IterationInterval(400))\n\nWe now define some useful diagnostics for the flow. Namely, we define RichardsonNumber, RossbyNumber and ErtelPotentialVorticity:\n\nusing Oceanostics\n\nb = model.tracers.b + model.background_fields.tracers.b\nRi = RichardsonNumber(model, model.velocities..., b)\nRo = RossbyNumber(model)\nPV = ErtelPotentialVorticity(model, model.velocities..., b, model.coriolis)\n\nNote that the calculation of these quantities depends on the alignment with the true (geophysical) vertical and the rotation axis. Oceanostics already takes that into consideration by using model.buoyancy and model.coriolis, making their calculation much easier. Furthermore, passing the flag add_background=true automatically adds the model's BackgroundFields to the resolved perturbations, which is important in our case for the correct calculation of nabla b with the background stratification.\n\nNow we write these quantities to a NetCDF file:\n\noutput_fields = (; Ri, Ro, PV, b)\n\nusing NCDatasets\nfilename = \"tilted_bottom_boundary_layer\"\nsimulation.output_writers[:nc] = NetCDFWriter(model, output_fields,\n                                              filename = joinpath(@__DIR__, filename),\n                                              schedule = TimeInterval(20minutes),\n                                              overwrite_existing = true)","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/#Run-the-simulation-and-process-results","page":"Tilted bottom boundary layer","title":"Run the simulation and process results","text":"To run the simulation:\n\nrun!(simulation)\n\nNow we'll read the results and plot an animation\n\nds = NCDataset(simulation.output_writers[:nc].filepath)\n\nWe now use Makie to create the figure and its axes\n\nusing CairoMakie\n\nset_theme!(Theme(fontsize = 20))\nfig = Figure()\n\nkwargs = (xlabel=\"x [m]\", ylabel=\"z [m]\", height=150, width=250)\nax1 = Axis(fig[2, 1]; title = \"Ri\", kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Ro\", kwargs...)\nax3 = Axis(fig[2, 3]; title = \"PV\", kwargs...);\nnothing #hide\n\nNext we an Observable to lift the values at each specific time and plot heatmaps, along with their colorbars, with buoyancy contours on top\n\nn = Observable(1)\n\nx_caa = ds[\"x_caa\"][:]\nx_faa = ds[\"x_faa\"][:]\nz_aac = ds[\"z_aac\"][:]\nz_aaf = ds[\"z_aaf\"][:]\n\nbâ‚™ = @lift ds[\"b\"][:, :, $n]\n\nRiâ‚™ = @lift ds[\"Ri\"][:, :, $n]\nhm1 = heatmap!(ax1, x_caa, z_aaf, Riâ‚™; colormap = :coolwarm, colorrange = (-1, +1))\ncontour!(ax1, x_caa, z_aac, bâ‚™; levels=10, color=:white, linestyle=:dash, linewidth=0.5)\nColorbar(fig[3, 1], hm1, vertical=false, height=8, ticklabelsize=14)\n\nRoâ‚™ = @lift ds[\"Ro\"][:, :, $n]\nhm2 = heatmap!(ax2, x_faa, z_aaf, Roâ‚™; colormap = :balance, colorrange = (-10, +10))\ncontour!(ax2, x_caa, z_aac, bâ‚™; levels=10, color=:black, linestyle=:dash, linewidth=0.5)\nColorbar(fig[3, 2], hm2, vertical=false, height=8, ticklabelsize=14)\n\nPVâ‚™ = @lift ds[\"PV\"][:, :, $n]\nhm3 = heatmap!(ax3, x_faa, z_aaf, PVâ‚™; colormap = :coolwarm, colorrange = NÂ²*fâ‚€.*(-1.5, +1.5))\ncontour!(ax3, x_caa, z_aac, bâ‚™; levels=10, color=:white, linestyle=:dash, linewidth=0.5)\nColorbar(fig[3, 3], hm3, vertical=false, height=8, ticklabelsize=14);\nnothing #hide\n\nNow we mark the time by placing a vertical line in the bottom panel and adding a helpful title\n\ntimes = ds[\"time\"][:]\ntitle = @lift \"Time = \" * string(prettytime(times[$n]))\nfig[1, 1:3] = Label(fig, title, fontsize=24, tellwidth=false);\nnothing #hide\n\nFinally, we adjust the figure dimensions to fit all the panels and record a movie\n\nresize_to_layout!(fig)\n\n@info \"Animating...\"\nrecord(fig, filename * \".mp4\", 1:length(times), framerate=10) do i\n       n[] = i\nend\n\nclose(ds)\n\n(Image: )\n\nThe animation shows negative PV being produced at the bottom due to drag, which leads to the emergence of centrifulgal-symmetric instabilities, which become turbulent and erode stratification (as can be seen by inspecting Ri). Note that there are some boundary effects on the upper boundary, likely caused by interaction internal waves that are produced by the bottom turbulence. These effects are, to some degree, expected, and a sponge/relaxation layer at the top is needed to minimize them in a production-ready code.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"library/","page":"Function library","title":"Function library","text":"Pages = [\"library.md\"]","category":"section"},{"location":"library/#Library","page":"Function library","title":"Library","text":"Documentation for the public user interface.","category":"section"},{"location":"library/#Oceanostics.add_background_fields-Tuple{Any}","page":"Function library","title":"Oceanostics.add_background_fields","text":"add_background_fields(model)\n\n\nAdd background fields (velocities and tracers only) to their perturbations.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.perturbation_fields-Tuple{Any}","page":"Function library","title":"Oceanostics.perturbation_fields","text":"perturbation_fields(model; kwargs...)\n\n\nRemove mean fields from the model resolved fields.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TracerEquation.Advection-NTuple{6, Any}","page":"Function library","title":"Oceanostics.TracerEquation.Advection","text":"Advection(model, u, v, w, c, advection; location)\n\n\nCalculates the advection of the tracer c as\n\nADV = âˆ‚â±¼ (uâ±¼ c)\n\nusing Oceananigans' kernel div_Uc.\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid; tracers=:a);\n\njulia> ADV = TracerEquation.Advection(model, :a)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—4Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: div_Uc (generic function with 10 methods)\nâ””â”€â”€ arguments: (\"Centered\", \"NamedTuple\", \"Field\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TracerEquation.Diffusion-NTuple{8, Any}","page":"Function library","title":"Oceanostics.TracerEquation.Diffusion","text":"Diffusion(\n    model,\n    val_tracer_index,\n    c,\n    closure,\n    closure_fields,\n    clock,\n    model_fields,\n    buoyancy;\n    location\n)\n\n\nCalculates the diffusion term (excluding anything due to the bathymetry) as\n\nDIFF = âˆ‚â±¼ qá¶œâ±¼,\n\nwhere qá¶œâ±¼ is the diffusion tensor for tracer c, using the Oceananigans' kernel âˆ‡_dot_qá¶œ.\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid; tracers=:a);\n\njulia> DIFF = TracerEquation.Diffusion(model, :a)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—4Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: âˆ‡_dot_qá¶œ (generic function with 10 methods)\nâ””â”€â”€ arguments: (\"Nothing\", \"Nothing\", \"Val\", \"Field\", \"Clock\", \"NamedTuple\", \"Nothing\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TracerEquation.Forcing-NTuple{4, Any}","page":"Function library","title":"Oceanostics.TracerEquation.Forcing","text":"Forcing(model, forcing, clock, model_fields; location)\n\n\nCalculate the forcing term Fá¶œ on the equation for tracer c for model.\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid; tracers=:a);\n\njulia> FORC = TracerEquation.Forcing(model, :a)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—4Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: Returns (generic function with 1 method)\nâ””â”€â”€ arguments: (\"Clock\", \"NamedTuple\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TracerEquation.ImmersedDiffusion-NTuple{8, Any}","page":"Function library","title":"Oceanostics.TracerEquation.ImmersedDiffusion","text":"ImmersedDiffusion(\n    model,\n    c,\n    c_immersed_bc,\n    closure,\n    closure_fields,\n    val_tracer_index,\n    clock,\n    model_fields;\n    location\n)\n\n\nCalculates the diffusion term due to the bathymetry term as\n\nDIFF = âˆ‚â±¼ ð“†á¶œâ±¼,\n\nwhere ð“†á¶œâ±¼ is the bathymetry-led diffusion tensor for tracer c, using the Oceananigans' kernel immersed_âˆ‡_dot_qá¶œ.\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid; tracers=:a);\n\njulia> DIFF = TracerEquation.ImmersedDiffusion(model, :a)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—4Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: immersed_âˆ‡_dot_qá¶œ (generic function with 2 methods)\nâ””â”€â”€ arguments: (\"Field\", \"Nothing\", \"Nothing\", \"Nothing\", \"Val\", \"Clock\", \"NamedTuple\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TracerEquation.TotalDiffusion-NTuple{9, Any}","page":"Function library","title":"Oceanostics.TracerEquation.TotalDiffusion","text":"TotalDiffusion(\n    model,\n    c,\n    c_immersed_bc,\n    closure,\n    closure_fields,\n    val_tracer_index,\n    clock,\n    model_fields,\n    buoyancy;\n    location\n)\n\n\nCalculates the total diffusion term as\n\nDIFF = âˆ‚â±¼ qá¶œâ±¼ + âˆ‚â±¼ ð“†á¶œâ±¼,\n\nc. The calculation is done using the Oceananigans' kernels âˆ‡_dot_qá¶œ and immersed_âˆ‡_dot_qá¶œ. where qá¶œâ±¼ is the interior diffusion tensor and ð“†á¶œâ±¼ is the bathymetry-led diffusion tensor for tracer\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid; tracers=:a);\n\njulia> DIFF = TracerEquation.TotalDiffusion(model, :a)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—4Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: total_âˆ‡_dot_qá¶œ (generic function with 1 method)\nâ””â”€â”€ arguments: (\"Field\", \"Nothing\", \"Nothing\", \"Nothing\", \"Val\", \"Clock\", \"NamedTuple\", \"Nothing\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TracerVarianceEquation.TracerVarianceDiffusion-Tuple{Any, Any}","page":"Function library","title":"Oceanostics.TracerVarianceEquation.TracerVarianceDiffusion","text":"TracerVarianceDiffusion(model, tracer_name; location)\n\n\nReturn a KernelFunctionOperation that computes the diffusive term of the tracer variance prognostic equation using Oceananigans' diffusive tracer flux divergence kernel:\n\n    DIFF = 2 c âˆ‚â±¼Fâ±¼\n\nwhere c is the tracer, and Fâ±¼ is the tracer's diffusive flux in the j-th direction.\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid; tracers=:b, closure=SmagorinskyLilly());\n\njulia> DIFF = TracerVarianceEquation.TracerVarianceDiffusion(model, :b)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—4Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: câˆ‡_dot_qá¶œ (generic function with 1 method)\nâ””â”€â”€ arguments: (\"Oceananigans.TurbulenceClosures.Smagorinskys.Smagorinsky\", \"NamedTuple\", \"Val\", \"Field\", \"Clock\", \"NamedTuple\", \"Nothing\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TracerVarianceEquation.TracerVarianceDissipationRate-Tuple{Any, Any}","page":"Function library","title":"Oceanostics.TracerVarianceEquation.TracerVarianceDissipationRate","text":"TracerVarianceDissipationRate(\n    model,\n    tracer_name;\n    tracer,\n    location\n)\n\n\nReturn a KernelFunctionOperation that computes the isotropic variance dissipation rate for tracer_name in model.tracers. The isotropic variance dissipation rate is defined as\n\n    Ï‡ = 2 âˆ‚â±¼c â‹… Fâ±¼\n\nwhere Fâ±¼ is the diffusive flux of c in the j-th direction and âˆ‚â±¼ is the gradient operator. Ï‡ is implemented in its conservative formulation based on the equation above.\n\nNote that often Ï‡ is written as Ï‡ = 2Îº (âˆ‡c â‹… âˆ‡c), which is the special case for Fickian diffusion (Îº is the tracer diffusivity).\n\nHere tracer_name is needed even when passing tracer in order to get the appropriate tracer_index. When passing tracer, this function should be used as\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid; tracers=:b, closure=SmagorinskyLilly());\n\njulia> Ï‡ = TracerVarianceEquation.TracerVarianceDissipationRate(model, :b)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—4Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: tracer_variance_dissipation_rate_ccc (generic function with 1 method)\nâ””â”€â”€ arguments: (\"Oceananigans.TurbulenceClosures.Smagorinskys.Smagorinsky\", \"NamedTuple\", \"Val\", \"Field\", \"Clock\", \"NamedTuple\", \"Nothing\")\n\njulia> bÌ„ = Field(Average(model.tracers.b, dims=(1,2)));\n\njulia> bâ€² = model.tracers.b - bÌ„;\n\njulia> Ï‡b = TracerVarianceEquation.TracerVarianceDissipationRate(model, :b, tracer=bâ€²)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—4Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: tracer_variance_dissipation_rate_ccc (generic function with 1 method)\nâ””â”€â”€ arguments: (\"Oceananigans.TurbulenceClosures.Smagorinskys.Smagorinsky\", \"NamedTuple\", \"Val\", \"Oceananigans.AbstractOperations.BinaryOperation\", \"Clock\", \"NamedTuple\", \"Nothing\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TracerVarianceEquation.TracerVarianceTendency-Tuple{NonhydrostaticModel, Any}","page":"Function library","title":"Oceanostics.TracerVarianceEquation.TracerVarianceTendency","text":"TracerVarianceTendency(model, tracer_name; location)\n\n\nReturn a KernelFunctionOperation that computes the tracer variance tendency:\n\nTEND = 2 c âˆ‚â‚œc\n\nwhere c is the tracer and âˆ‚â‚œc is the tracer tendency (computed using Oceananigans' tracer tendency kernel).\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size = (1, 1, 4), extent = (1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid; tracers=:b);\n\njulia> Ï‡ = TracerVarianceEquation.TracerVarianceTendency(model, :b)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—3 halo\nâ”œâ”€â”€ kernel_function: câˆ‚â‚œcá¶œá¶œá¶œ (generic function with 1 method)\nâ””â”€â”€ arguments: (\"Val\", \"Val\", \"Centered\", \"Nothing\", \"Nothing\", \"Nothing\", \"Nothing\", \"Oceananigans.Models.NonhydrostaticModels.BackgroundFields\", \"NamedTuple\", \"NamedTuple\", \"NamedTuple\", \"Nothing\", \"Clock\", \"Returns\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TurbulentKineticEnergyEquation.TurbulentKineticEnergyIsotropicDissipationRate-Tuple{Any, Any, Any, Vararg{Any}}","page":"Function library","title":"Oceanostics.TurbulentKineticEnergyEquation.TurbulentKineticEnergyIsotropicDissipationRate","text":"TurbulentKineticEnergyIsotropicDissipationRate(\n    u,\n    v,\n    w,\n    args;\n    U,\n    V,\n    W,\n    location\n)\n\n\nCalculate the Turbulent Kinetic Energy Isotropic Dissipation Rate, defined as\n\nÎµ = 2 Î½ S'áµ¢â±¼S'áµ¢â±¼,\n\nwhere S'áµ¢â±¼ is the strain rate tensor, for a fluid with an isotropic turbulence closure (i.e., a turbulence closure where Î½ (eddy or not) is the same for all directions.\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid; closure=ScalarDiffusivity(Î½=1e-4));\n\njulia> TurbulentKineticEnergyEquation.IsotropicDissipationRate(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—4Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: isotropic_viscous_dissipation_rate_ccc (generic function with 1 method)\nâ””â”€â”€ arguments: (\"Field\", \"Field\", \"Field\", \"NamedTuple\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TurbulentKineticEnergyEquation.TurbulentKineticEnergy-NTuple{4, Any}","page":"Function library","title":"Oceanostics.TurbulentKineticEnergyEquation.TurbulentKineticEnergy","text":"TurbulentKineticEnergy(model, u, v, w; U, V, W, location)\n\n\nCalculate the turbulent kinetic energy of model.\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid);\n\njulia> TKE = TurbulentKineticEnergyEquation.TurbulentKineticEnergy(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—4Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: turbulent_kinetic_energy_ccc (generic function with 1 method)\nâ””â”€â”€ arguments: (\"Field\", \"Field\", \"Field\", \"Oceananigans.Fields.ZeroField\", \"Oceananigans.Fields.ZeroField\", \"Oceananigans.Fields.ZeroField\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TurbulentKineticEnergyEquation.TurbulentKineticEnergyShearProductionRate-NTuple{6, Any}","page":"Function library","title":"Oceanostics.TurbulentKineticEnergyEquation.TurbulentKineticEnergyShearProductionRate","text":"TurbulentKineticEnergyShearProductionRate(\n    uâ€²,\n    vâ€²,\n    wâ€²,\n    U,\n    V,\n    W;\n    grid,\n    location\n)\n\n\nCalculate the total shear production rate (sum of the shear production rates in the model's x, y and z directions):\n\nSHEAR = XSHEAR + YSHEAR + ZSHEAR = uáµ¢â€²uâ±¼â€²âˆ‚â±¼(Uáµ¢)\n\nwhere XSHEAR, YSHEAR and ZSHEAR are the shear production rates in the x, y and z directions, respectively, uáµ¢â€² and uâ±¼â€² are the velocity perturbations in the i and j directions, respectively, and âˆ‚â±¼ is the derivative in the j direction.\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid);\n\njulia> SHEAR = TurbulentKineticEnergyEquation.ShearProductionRate(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—4Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: shear_production_rate_ccc (generic function with 1 method)\nâ””â”€â”€ arguments: (\"Field\", \"Field\", \"Field\", \"Oceananigans.Fields.ZeroField\", \"Oceananigans.Fields.ZeroField\", \"Oceananigans.Fields.ZeroField\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TurbulentKineticEnergyEquation.TurbulentKineticEnergyXShearProductionRate-NTuple{6, Any}","page":"Function library","title":"Oceanostics.TurbulentKineticEnergyEquation.TurbulentKineticEnergyXShearProductionRate","text":"TurbulentKineticEnergyXShearProductionRate(\n    uâ€²,\n    vâ€²,\n    wâ€²,\n    U,\n    V,\n    W;\n    grid,\n    location\n)\n\n\nCalculate the shear production rate in the model's x direction:\n\nXSHEAR = uáµ¢â€²uâ€²âˆ‚x(Uáµ¢)\n\nwhere uáµ¢â€² is the velocity perturbation in the i direction, uâ€² is the velocity perturbation in the x direction, Uáµ¢ is the background velocity in the i direction, and âˆ‚x is the horizontal derivative.\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid);\n\njulia> XSHEAR = TurbulentKineticEnergyEquation.XShearProductionRate(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—4Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: shear_production_rate_x_ccc (generic function with 1 method)\nâ””â”€â”€ arguments: (\"Field\", \"Field\", \"Field\", \"Oceananigans.Fields.ZeroField\", \"Oceananigans.Fields.ZeroField\", \"Oceananigans.Fields.ZeroField\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TurbulentKineticEnergyEquation.TurbulentKineticEnergyYShearProductionRate-NTuple{6, Any}","page":"Function library","title":"Oceanostics.TurbulentKineticEnergyEquation.TurbulentKineticEnergyYShearProductionRate","text":"TurbulentKineticEnergyYShearProductionRate(\n    uâ€²,\n    vâ€²,\n    wâ€²,\n    U,\n    V,\n    W;\n    grid,\n    location\n)\n\n\nCalculate the shear production rate in the model's y direction:\n\nYSHEAR = uáµ¢â€²vâ€²âˆ‚y(Uáµ¢)\n\nwhere uáµ¢â€² is the velocity perturbation in the i direction, vâ€² is the velocity perturbation in the y direction, Uáµ¢ is the background velocity in the i direction, and âˆ‚y is the vertical derivative.\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid);\n\njulia> YSHEAR = TurbulentKineticEnergyEquation.YShearProductionRate(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—4Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: shear_production_rate_y_ccc (generic function with 1 method)\nâ””â”€â”€ arguments: (\"Field\", \"Field\", \"Field\", \"Oceananigans.Fields.ZeroField\", \"Oceananigans.Fields.ZeroField\", \"Oceananigans.Fields.ZeroField\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TurbulentKineticEnergyEquation.TurbulentKineticEnergyZShearProductionRate-NTuple{6, Any}","page":"Function library","title":"Oceanostics.TurbulentKineticEnergyEquation.TurbulentKineticEnergyZShearProductionRate","text":"TurbulentKineticEnergyZShearProductionRate(\n    uâ€²,\n    vâ€²,\n    wâ€²,\n    U,\n    V,\n    W;\n    grid,\n    location\n)\n\n\nCalculate the shear production rate in the model's z direction:\n\nZSHEAR = uáµ¢â€²wâ€²âˆ‚z(Uáµ¢)\n\nwhere uáµ¢â€² is the velocity perturbation in the i direction, wâ€² is the vertical velocity perturbation, Uáµ¢ is the background velocity in the i direction, and âˆ‚z is the vertical derivative.\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid);\n\njulia> ZSHEAR = TurbulentKineticEnergyEquation.ZShearProductionRate(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—4Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: shear_production_rate_z_ccc (generic function with 1 method)\nâ””â”€â”€ arguments: (\"Field\", \"Field\", \"Field\", \"Oceananigans.Fields.ZeroField\", \"Oceananigans.Fields.ZeroField\", \"Oceananigans.Fields.ZeroField\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.KineticEnergyEquation.BuoyancyProduction-Tuple{NonhydrostaticModel}","page":"Function library","title":"Oceanostics.KineticEnergyEquation.BuoyancyProduction","text":"BuoyancyProduction(model; velocities, tracers, location)\n\n\nReturn a KernelFunctionOperation that computes the buoyancy production term, defined as\n\nBP = uáµ¢báµ¢\n\nwhere báµ¢ is the component of the buoyancy acceleration in the i-th direction (which is zero for x and y, except when gravity_unit_vector isn't aligned with the grid's z-direction) and all three components of i=1,2,3 are added up.\n\nBy default, the buoyancy production will be calculated using the resolved velocities and tracers:\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size = (1, 1, 4), extent = (1,1,1));\n\njulia> model = NonhydrostaticModel(grid; buoyancy=BuoyancyTracer(), tracers=:b);\n\njulia> using Oceanostics.KineticEnergyEquation: BuoyancyProduction\n\njulia> wb = BuoyancyProduction(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—3 halo\nâ”œâ”€â”€ kernel_function: uáµ¢báµ¢á¶œá¶œá¶œ (generic function with 1 method)\nâ””â”€â”€ arguments: (\"NamedTuple\", \"BuoyancyForce\", \"NamedTuple\")\n\nIf we want to calculate only the turbulent buoyancy production rate, we can do so by passing turbulent perturbations to the velocities and/or tracers options):\n\njulia> wâ€² = Field(model.velocities.w - Field(Average(model.velocities.w)));\n\njulia> bâ€² = Field(model.tracers.b - Field(Average(model.tracers.b)));\n\njulia> wâ€²bâ€² = BuoyancyProduction(model, velocities=(u=model.velocities.u, v=model.velocities.v, w=wâ€²), tracers=(b=bâ€²,))\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—3 halo\nâ”œâ”€â”€ kernel_function: uáµ¢báµ¢á¶œá¶œá¶œ (generic function with 1 method)\nâ””â”€â”€ arguments: (\"NamedTuple\", \"BuoyancyForce\", \"NamedTuple\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.KineticEnergyEquation.DissipationRate-Tuple{Any}","page":"Function library","title":"Oceanostics.KineticEnergyEquation.DissipationRate","text":"DissipationRate(model; U, V, W, location)\n\n\nCalculate the Kinetic Energy Dissipation Rate, defined as\n\nÎµ = âˆ‚â±¼uáµ¢ â‹… Fáµ¢â±¼\n\nwhere âˆ‚â±¼uáµ¢ is the velocity gradient tensor and Fáµ¢â±¼ is the stress tensor.\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid; closure=ScalarDiffusivity(Î½=1e-4));\n\njulia> Îµ = KineticEnergyEquation.DissipationRate(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—4Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: viscous_dissipation_rate_ccc (generic function with 1 method)\nâ””â”€â”€ arguments: (\"Nothing\", \"NamedTuple\", \"NamedTuple\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.KineticEnergyEquation.KineticEnergy-NTuple{4, Any}","page":"Function library","title":"Oceanostics.KineticEnergyEquation.KineticEnergy","text":"KineticEnergy(model, u, v, w; location)\n\n\nCalculate the kinetic energy of model manually specifying u, v and w.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.KineticEnergyEquation.KineticEnergy-Tuple{Any}","page":"Function library","title":"Oceanostics.KineticEnergyEquation.KineticEnergy","text":"KineticEnergy(model; kwargs...)\n\n\nCalculate the kinetic energy of model.\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid);\n\njulia> KE = KineticEnergyEquation.KineticEnergy(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—4Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: kinetic_energy_ccc (generic function with 1 method)\nâ””â”€â”€ arguments: (\"Field\", \"Field\", \"Field\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.KineticEnergyEquation.KineticEnergyAdvection-Tuple{NonhydrostaticModel}","page":"Function library","title":"Oceanostics.KineticEnergyEquation.KineticEnergyAdvection","text":"KineticEnergyAdvection(model; velocities, location)\n\n\nReturn a KernelFunctionOperation that computes the advection term, defined as\n\nADV = uáµ¢âˆ‚â±¼(uáµ¢uâ±¼)\n\nBy default, the buoyancy production will be calculated using the resolved velocities and users cab use the keyword velocities to modify that behavior:\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size = (1, 1, 4), extent = (1,1,1));\n\njulia> model = NonhydrostaticModel(grid);\n\njulia> using Oceanostics.KineticEnergyEquation: KineticEnergyAdvection\n\njulia> ADV = KineticEnergyAdvection(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—3 halo\nâ”œâ”€â”€ kernel_function: uáµ¢âˆ‚â±¼uâ±¼uáµ¢á¶œá¶œá¶œ (generic function with 1 method)\nâ””â”€â”€ arguments: (\"NamedTuple\", \"Centered\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.KineticEnergyEquation.KineticEnergyForcing-Tuple{NonhydrostaticModel}","page":"Function library","title":"Oceanostics.KineticEnergyEquation.KineticEnergyForcing","text":"KineticEnergyForcing(model; location)\n\n\nReturn a KernelFunctionOperation that computes the forcing term of the KE prognostic equation:\n\n    FORC = uáµ¢Fáµ¤áµ¢\n\nwhere uáµ¢ are the velocity components and Fáµ¤áµ¢ is the forcing term(s) in the uáµ¢ prognostic equation (i.e. the forcing for uáµ¢).\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid);\n\njulia> FORC = KineticEnergyEquation.KineticEnergyForcing(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—4Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: uáµ¢Fáµ¤áµ¢á¶œá¶œá¶œ (generic function with 1 method)\nâ””â”€â”€ arguments: (\"NamedTuple\", \"Clock\", \"NamedTuple\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.KineticEnergyEquation.KineticEnergyIsotropicDissipationRate-NTuple{7, Any}","page":"Function library","title":"Oceanostics.KineticEnergyEquation.KineticEnergyIsotropicDissipationRate","text":"KineticEnergyIsotropicDissipationRate(\n    u,\n    v,\n    w,\n    closure,\n    closure_fields,\n    model_fields,\n    clock;\n    location\n)\n\n\nCalculate the Viscous Dissipation Rate as\n\nÎµ = 2 Î½ Sáµ¢â±¼Sáµ¢â±¼,\n\nwhere Sáµ¢â±¼ is the strain rate tensor, for a fluid with an isotropic turbulence closure (i.e., a turbulence closure where Î½ (eddy or not) is the same for all directions).\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid; closure=ScalarDiffusivity(Î½=1e-4));\n\njulia> Îµ = KineticEnergyEquation.KineticEnergyIsotropicDissipationRate(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—4Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: isotropic_viscous_dissipation_rate_ccc (generic function with 1 method)\nâ””â”€â”€ arguments: (\"Field\", \"Field\", \"Field\", \"NamedTuple\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.KineticEnergyEquation.KineticEnergyPressureRedistribution-Tuple{NonhydrostaticModel}","page":"Function library","title":"Oceanostics.KineticEnergyEquation.KineticEnergyPressureRedistribution","text":"KineticEnergyPressureRedistribution(\n    model;\n    velocities,\n    pressure,\n    location\n)\n\n\nReturn a KernelFunctionOperation that computes the pressure redistribution term:\n\nPR = uáµ¢âˆ‚áµ¢p\n\nwhere p is the pressure. By default p is taken to be the total pressure (nonhydrostatic + hydrostatic):\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size = (1, 1, 4), extent = (1,1,1));\n\njulia> model = NonhydrostaticModel(grid);\n\njulia> using Oceanostics.KineticEnergyEquation: KineticEnergyPressureRedistribution\n\njulia> âˆ‡uâƒ—p = KineticEnergyPressureRedistribution(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—3 halo\nâ”œâ”€â”€ kernel_function: uáµ¢âˆ‚áµ¢pá¶œá¶œá¶œ (generic function with 1 method)\nâ””â”€â”€ arguments: (\"NamedTuple\", \"Field\")\n\nWe can also pass velocities and pressure keywords to perform more specific calculations. The example below illustrates calculation of the nonhydrostatic contribution to the pressure redistrubution term:\n\njulia> âˆ‡uâƒ—pNHS = KineticEnergyPressureRedistribution(model, pressure=model.pressures.pNHS)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—3 halo\nâ”œâ”€â”€ kernel_function: uáµ¢âˆ‚áµ¢pá¶œá¶œá¶œ (generic function with 1 method)\nâ””â”€â”€ arguments: (\"NamedTuple\", \"Field\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.KineticEnergyEquation.KineticEnergyStress-Tuple{Any}","page":"Function library","title":"Oceanostics.KineticEnergyEquation.KineticEnergyStress","text":"KineticEnergyStress(model; location)\n\n\nReturn a KernelFunctionOperation that computes the diffusive term of the KE prognostic equation:\n\n    DIFF = uáµ¢âˆ‚â±¼Ï„áµ¢â±¼\n\nwhere uáµ¢ are the velocity components and Ï„áµ¢â±¼ is the diffusive flux of i momentum in the j-th direction.\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid; closure=ScalarDiffusivity(Î½=1e-4));\n\njulia> DIFF = KineticEnergyEquation.KineticEnergyStress(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—4Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: uáµ¢âˆ‚â±¼_Ï„áµ¢â±¼á¶œá¶œá¶œ (generic function with 1 method)\nâ””â”€â”€ arguments: (\"ScalarDiffusivity\", \"Nothing\", \"Clock\", \"NamedTuple\", \"Nothing\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.KineticEnergyEquation.KineticEnergyTendency-Tuple{NonhydrostaticModel}","page":"Function library","title":"Oceanostics.KineticEnergyEquation.KineticEnergyTendency","text":"KineticEnergyTendency(model; location)\n\n\nReturn a KernelFunctionOperation that computes the tendency uáµ¢Gáµ¢ of the KE, excluding the nonhydrostatic pressure contribution:\n\nKET = Â½âˆ‚â‚œuáµ¢Â² = uáµ¢Gáµ¢ - uáµ¢âˆ‚áµ¢pâ‚™â‚•â‚›\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(size = (1, 1, 4), extent = (1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid);\n\njulia> using Oceanostics.KineticEnergyEquation: KineticEnergyTendency\n\njulia> ke_tendency = KineticEnergyTendency(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1Ã—1Ã—3 halo\nâ”œâ”€â”€ kernel_function: uáµ¢Gáµ¢á¶œá¶œá¶œ (generic function with 1 method)\nâ””â”€â”€ arguments: (\"Centered\", \"Nothing\", \"Nothing\", \"Nothing\", \"Nothing\", \"Nothing\", \"Nothing\", \"Nothing\", \"Oceananigans.Models.NonhydrostaticModels.BackgroundFields\", \"NamedTuple\", \"NamedTuple\", \"NamedTuple\", \"Nothing\", \"Nothing\", \"Clock\", \"NamedTuple\")\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics.BottomCellValue-Tuple{Any}","page":"Function library","title":"Oceanostics.FlowDiagnostics.BottomCellValue","text":"BottomCellValue(diagnostic)\n\n\nReturns the value of the given diagnostic at the bottom, which can be either the bottom of the domain (lowest vertical level) or an immersed bottom.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics.MixedLayerDepth-Tuple{Oceananigans.Grids.AbstractGrid, Vararg{Any}}","page":"Function library","title":"Oceanostics.FlowDiagnostics.MixedLayerDepth","text":"MixedLayerDepth(grid, args; criterion)\n\n\nReturns the mixed layer depth defined as the depth at which criterion is true.\n\nDefaults to DensityAnomalyCriterion where the depth is that at which the density is some threshold (defaults to 0.125kg/mÂ³) higher than the surface density.\n\nWhen DensityAnomalyCriterion is used, the arguments buoyancy_formulation and C should be supplied where buoyancy_formulation should be the buoyancy model, and C should be a named tuple of (; T, S), (; T) or (; S) (the latter two if the buoyancy model specifies a constant salinity or temperature).\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics.uâ‚•_norm_ccc-NTuple{8, Any}","page":"Function library","title":"Oceanostics.FlowDiagnostics.uâ‚•_norm_ccc","text":"uâ‚•_norm_ccc(i, j, k, grid, Ã», vÌ‚, Åµ, vertical_dir)\n\n\nReturn the (true) horizontal velocity magnitude.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics.wÂ²_from_uâƒ—_tilted_ccc-NTuple{8, Any}","page":"Function library","title":"Oceanostics.FlowDiagnostics.wÂ²_from_uâƒ—_tilted_ccc","text":"Get w from uÌ‚, vÌ‚, wÌ‚ and based on the direction given by the unit vector vertical_dir.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics.AbstractAnomalyCriterion","page":"Function library","title":"Oceanostics.FlowDiagnostics.AbstractAnomalyCriterion","text":"abstract type AbstractAnomalyCriterion\n\nAn abstract mixed layer depth criterion where the mixed layer is defined to be anomaly + threshold greater than the surface value of anomaly.\n\nAbstractAnomalyCriterion types should provide a method for the function anomaly in the form anomaly(criterion, i, j, k, grid, args...), and should have a property threshold.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceanostics.FlowDiagnostics.BuoyancyAnomalyCriterion","page":"Function library","title":"Oceanostics.FlowDiagnostics.BuoyancyAnomalyCriterion","text":"struct BuoyancyAnomalyCriterion{FT} <: Oceanostics.FlowDiagnostics.AbstractAnomalyCriterion\n\nDefines the mixed layer to be the depth at which the buoyancy is more than threshold greater than the surface buoyancy (but the pertubaton is usually negative).\n\nWhen this model is used, the arguments buoyancy_formulation and C should be supplied where C should be the named tuple (; b), with b the buoyancy tracer.\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceanostics.FlowDiagnostics.DensityAnomalyCriterion","page":"Function library","title":"Oceanostics.FlowDiagnostics.DensityAnomalyCriterion","text":"struct DensityAnomalyCriterion{FT} <: Oceanostics.FlowDiagnostics.AbstractAnomalyCriterion\n\nDefines the mixed layer to be the depth at which the density is more than threshold greater than the surface density.\n\nWhen this model is used, the arguments buoyancy_formulation and C should be supplied where buoyancy_formulation should be the buoyancy model, and C should be a named tuple of (; T, S), (; T) or (; S) (the latter two if the buoyancy model specifies a constant salinity or temperature).\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceanostics.FlowDiagnostics.DirectionalErtelPotentialVorticity-Tuple{Any, Any}","page":"Function library","title":"Oceanostics.FlowDiagnostics.DirectionalErtelPotentialVorticity","text":"DirectionalErtelPotentialVorticity(\n    model,\n    direction;\n    tracer_name,\n    loc\n)\n\n\nCalculate the contribution from a given direction to the Ertel Potential Vorticity basde on a model and a direction. The Ertel Potential Vorticity is defined as\n\nEPV = Ï‰â‚œâ‚’â‚œ â‹… âˆ‡b\n\nwhere Ï‰â‚œâ‚’â‚œ is the total (relative + planetary) vorticity vector, b is the buoyancy and âˆ‡ is the gradient operator.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics.ErtelPotentialVorticity-Tuple{Any}","page":"Function library","title":"Oceanostics.FlowDiagnostics.ErtelPotentialVorticity","text":"ErtelPotentialVorticity(model; tracer_name, loc)\n\n\nCalculate the Ertel Potential Vorticty for model, where the characteristics of the Coriolis rotation are taken from model.coriolis. The Ertel Potential Vorticity is defined as\n\nEPV = Ï‰â‚œâ‚’â‚œ â‹… âˆ‡b\n\nwhere Ï‰â‚œâ‚’â‚œ is the total (relative + planetary) vorticity vector, b is the buoyancy and âˆ‡ is the gradient operator.\n\njulia> using Oceananigans\n\njulia> grid = RectilinearGrid(topology = (Flat, Flat, Bounded), size = 4, extent = 1);\n\njulia> NÂ² = 1e-6;\n\njulia> b_bcs = FieldBoundaryConditions(top=GradientBoundaryCondition(NÂ²));\n\njulia> model = NonhydrostaticModel(grid; coriolis=FPlane(1e-4), buoyancy=BuoyancyTracer(), tracers=:b, boundary_conditions=(; b=b_bcs));\n\njulia> stratification(z) = NÂ² * z;\n\njulia> set!(model, b=stratification)\n\njulia> using Oceanostics: ErtelPotentialVorticity\n\njulia> EPV = ErtelPotentialVorticity(model)\nKernelFunctionOperation at (Face, Face, Face)\nâ”œâ”€â”€ grid: 1Ã—1Ã—4 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0Ã—0Ã—3 halo\nâ”œâ”€â”€ kernel_function: ertel_potential_vorticity_fff (generic function with 1 method)\nâ””â”€â”€ arguments: (\"Field\", \"Field\", \"Field\", \"Field\", \"Int64\", \"Int64\", \"Float64\")\n\njulia> interior(Field(EPV))\n1Ã—1Ã—5 view(::Array{Float64, 3}, 1:1, 1:1, 4:8) with eltype Float64:\n[:, :, 1] =\n 0.0\n\n[:, :, 2] =\n 1.0000000000000002e-10\n\n[:, :, 3] =\n 9.999999999999998e-11\n\n[:, :, 4] =\n 1.0000000000000002e-10\n\n[:, :, 5] =\n 1.0e-10\n\nNote that EPV values are correctly calculated both in the interior and the boundaries. In the interior and top boundary, EPV = fÃ—NÂ² = 10â»Â¹â°, while EPV = 0 at the bottom boundary since âˆ‚b/âˆ‚z is zero there.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics.MixedLayerDepthKernel","page":"Function library","title":"Oceanostics.FlowDiagnostics.MixedLayerDepthKernel","text":"struct MixedLayerDepthKernel{C}\n\n\n\n\n\n","category":"type"},{"location":"library/#Oceanostics.FlowDiagnostics.QVelocityGradientTensorInvariant-Tuple{Any}","page":"Function library","title":"Oceanostics.FlowDiagnostics.QVelocityGradientTensorInvariant","text":"QVelocityGradientTensorInvariant(model; loc)\n\n\nCalculate the value of the Q velocity gradient tensor invariant. This is usually just called Q and it is generally used for identifying and visualizing vortices in fluid flow.\n\nThe definition and nomenclature comes from the equation for the eigenvalues Î» of the velocity gradient tensor âˆ‚â±¼uáµ¢:\n\n    Î»Â³ + P Î»Â² + Q Î» + T = 0\n\nfrom where Q is defined as\n\n    Q = Â½ (Î©áµ¢â±¼Î©áµ¢â±¼ - Sáµ¢â±¼Sáµ¢â±¼)\n\nand where Sáµ¢â±¼= Â½(âˆ‚â±¼uáµ¢ + âˆ‚áµ¢uâ±¼) and Î©áµ¢â±¼= Â½(âˆ‚â±¼uáµ¢ - âˆ‚áµ¢uâ±¼). More info about it can be found in doi:10.1063/1.5124245.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics.RichardsonNumber-Tuple{Any}","page":"Function library","title":"Oceanostics.FlowDiagnostics.RichardsonNumber","text":"RichardsonNumber(model; loc)\n\n\nCalculate the Richardson Number as\n\n    Ri = (âˆ‚b/âˆ‚z) / (|âˆ‚uâƒ—â‚•/âˆ‚z|Â²)\n\nwhere z is the true vertical direction (ie anti-parallel to gravity).\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics.RossbyNumber-Tuple{Any}","page":"Function library","title":"Oceanostics.FlowDiagnostics.RossbyNumber","text":"RossbyNumber(\n    model;\n    loc,\n    add_background,\n    dWdy_bg,\n    dVdz_bg,\n    dUdz_bg,\n    dWdx_bg,\n    dUdy_bg,\n    dVdx_bg\n)\n\n\nCalculate the Rossby number using the vorticity in the rotation axis direction according to model.coriolis. Rossby number is defined as\n\n    Ro = Ï‰á¶» / f\n\nwhere Ï‰á¶» is the vorticity in the Coriolis axis of rotation and f is the Coriolis rotation frequency.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics.StrainRateTensorModulus-Tuple{Any}","page":"Function library","title":"Oceanostics.FlowDiagnostics.StrainRateTensorModulus","text":"StrainRateTensorModulus(model; loc)\n\n\nCalculate the modulus (absolute value) of the strain rate tensor S, which is defined as the symmetric part of the velocity gradient tensor:\n\n    Sáµ¢â±¼ = Â½(âˆ‚â±¼uáµ¢ + âˆ‚áµ¢uâ±¼)\n\nIts modulus is then defined (using Einstein summation notation) as\n\n    || Sáµ¢â±¼ || = âˆš(Sáµ¢â±¼ Sáµ¢â±¼)\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics.ThermalWindPotentialVorticity-Tuple{Any}","page":"Function library","title":"Oceanostics.FlowDiagnostics.ThermalWindPotentialVorticity","text":"ThermalWindPotentialVorticity(model; tracer_name, loc)\n\n\nCalculate the Potential Vorticty assuming thermal wind balance for model, where the characteristics of the Coriolis rotation are taken from model.coriolis. The Potential Vorticity in this case is defined as\n\n    TWPV = (f + Ï‰á¶») âˆ‚b/âˆ‚z - f ((âˆ‚U/âˆ‚z)Â² + (âˆ‚V/âˆ‚z)Â²)\n\nwhere f is the Coriolis frequency, Ï‰á¶» is the relative vorticity in the z direction, b is the buoyancy, and âˆ‚U/âˆ‚z and âˆ‚V/âˆ‚z comprise the thermal wind shear.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics.VorticityTensorModulus-Tuple{Any}","page":"Function library","title":"Oceanostics.FlowDiagnostics.VorticityTensorModulus","text":"VorticityTensorModulus(model; loc)\n\n\nCalculate the modulus (absolute value) of the vorticity tensor Î©, which is defined as the antisymmetric part of the velocity gradient tensor:\n\n    Î©áµ¢â±¼ = Â½(âˆ‚â±¼uáµ¢ - âˆ‚áµ¢uâ±¼)\n\nIts modulus is then defined (using Einstein summation notation) as\n\n    || Î©áµ¢â±¼ || = âˆš(Î©áµ¢â±¼ Î©áµ¢â±¼)\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.PotentialEnergyEquation.PotentialEnergy-Tuple{Any}","page":"Function library","title":"Oceanostics.PotentialEnergyEquation.PotentialEnergy","text":"PotentialEnergy(model; location, geopotential_height)\n\n\nReturn a KernelFunctionOperation to compute the PotentialEnergy per unit volume,\n\nEâ‚š = fracgÏÏâ‚€z = -bz\n\nat each grid location in model. PotentialEnergy is defined for both BuoyancyTracer and SeawaterBuoyancy. See the relevant Oceananigans.jl documentation on buoyancy models for more information about available options.\n\nThe optional keyword argument geopotential_height is only used if ones wishes to calculate Eâ‚š with a potential density referenced to geopotential_height, rather than in-situ density, when using a BoussinesqEquationOfState.\n\nExample\n\nUsage with a BuoyancyTracer buoyacny model\n\njulia> using Oceananigans, Oceanostics\n\njulia> grid = RectilinearGrid(size=100, z=(-1000, 0), topology=(Flat, Flat, Bounded))\n1Ã—1Ã—100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0Ã—0Ã—3 halo\nâ”œâ”€â”€ Flat x\nâ”œâ”€â”€ Flat y\nâ””â”€â”€ Bounded  z âˆˆ [-1000.0, 0.0] regularly spaced with Î”z=10.0\n\njulia> model = NonhydrostaticModel(grid; buoyancy=BuoyancyTracer(), tracers=(:b,))\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 1Ã—1Ã—100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0Ã—0Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: Centered(order=2)\nâ”œâ”€â”€ tracers: b\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = NegativeZDirection()\nâ””â”€â”€ coriolis: Nothing\n\njulia> PotentialEnergyEquation.PotentialEnergy(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0Ã—0Ã—3 halo\nâ”œâ”€â”€ kernel_function: minus_bz_ccc (generic function with 3 methods)\nâ””â”€â”€ arguments: (\"Field\",)\n\nThe default behaviour of PotentialEnergy uses the in-situ density in the calculation when the equation of state is a BoussinesqEquationOfState:\n\njulia> using Oceananigans, SeawaterPolynomials.TEOS10, Oceanostics\n\njulia> grid = RectilinearGrid(size=100, z=(-1000, 0), topology=(Flat, Flat, Bounded))\n1Ã—1Ã—100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0Ã—0Ã—3 halo\nâ”œâ”€â”€ Flat x\nâ”œâ”€â”€ Flat y\nâ””â”€â”€ Bounded  z âˆˆ [-1000.0, 0.0] regularly spaced with Î”z=10.0\n\njulia> tracers = (:T, :S)\n(:T, :S)\n\njulia> eos = TEOS10EquationOfState()\nBoussinesqEquationOfState{Float64}:\nâ”œâ”€â”€ seawater_polynomial: TEOS10SeawaterPolynomial{Float64}\nâ””â”€â”€ reference_density: 1020.0\n\njulia> buoyancy = SeawaterBuoyancy(equation_of_state=eos)\nSeawaterBuoyancy{Float64}:\nâ”œâ”€â”€ gravitational_acceleration: 9.80665\nâ””â”€â”€ equation_of_state: BoussinesqEquationOfState{Float64}\n\njulia> model = NonhydrostaticModel(grid; buoyancy, tracers)\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 1Ã—1Ã—100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0Ã—0Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: Centered(order=2)\nâ”œâ”€â”€ tracers: (T, S)\nâ”œâ”€â”€ closure: Nothing\nâ”œâ”€â”€ buoyancy: SeawaterBuoyancy with g=9.80665 and BoussinesqEquationOfState{Float64} with gÌ‚ = NegativeZDirection()\nâ””â”€â”€ coriolis: Nothing\n\njulia> PotentialEnergyEquation.PotentialEnergy(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0Ã—0Ã—3 halo\nâ”œâ”€â”€ kernel_function: minus_bz_ccc (generic function with 3 methods)\nâ””â”€â”€ arguments: (\"KernelFunctionOperation\", \"NamedTuple\")\n\nTo use a reference density set a constant value for the keyword argument geopotential_height and pass this the function. For example,\n\njulia> using Oceananigans, SeawaterPolynomials.TEOS10, Oceanostics\n\njulia> grid = RectilinearGrid(size=100, z=(-1000, 0), topology=(Flat, Flat, Bounded));\n\njulia> tracers = (:T, :S);\n\njulia> eos = TEOS10EquationOfState();\n\njulia> buoyancy = SeawaterBuoyancy(equation_of_state=eos);\n\njulia> model = NonhydrostaticModel(grid; buoyancy, tracers);\n\njulia> geopotential_height = 0; # density variable will be Ïƒâ‚€\n\njulia> PotentialEnergyEquation.PotentialEnergy(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 1Ã—1Ã—100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0Ã—0Ã—3 halo\nâ”œâ”€â”€ kernel_function: minus_bz_ccc (generic function with 3 methods)\nâ””â”€â”€ arguments: (\"KernelFunctionOperation\", \"NamedTuple\")\n\n\n\n\n\n","category":"method"},{"location":"generated/two_dimensional_turbulence/#two_d_turbulence_example","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence example","text":"In this example (based on the homonymous Oceananigans one) we simulate a 2D flow initialized with random noise and observe the flow evolve.\n\nBefore starting, make sure you have the required packages installed for this example, which can be done with\n\nusing Pkg\npkg\"add Oceananigans, Oceanostics, CairoMakie, Rasters\"","category":"section"},{"location":"generated/two_dimensional_turbulence/#Model-and-simulation-setup","page":"Two-dimensional turbulence","title":"Model and simulation setup","text":"We begin by creating a model with an isotropic diffusivity and fifth-order advection on a 128Â² grid.\n\nusing Oceananigans\n\ngrid = RectilinearGrid(size=(128, 128), extent=(2Ï€, 2Ï€), topology=(Periodic, Periodic, Flat))\n\nmodel = NonhydrostaticModel(grid; timestepper = :RungeKutta3,\n                            advection = UpwindBiased(order=5),\n                            closure = ScalarDiffusivity(Î½=1e-5))\n\nLet's give the model zero-mean grid-scale white noise as the initial condition\n\nusing Statistics\n\nu, v, w = model.velocities\n\nnoise(x, y) = rand()\nset!(model, u=noise, v=noise)\n\nu .-= mean(u)\nv .-= mean(v)\n\nWe use this model to create a simulation with a TimeStepWizard to maximize the Î”t\n\nsimulation = Simulation(model, Î”t=0.2, stop_time=50)\n\nwizard = TimeStepWizard(cfl=0.8, diffusive_cfl=0.8)\nsimulation.callbacks[:wizard] = Callback(wizard, IterationInterval(5))","category":"section"},{"location":"generated/two_dimensional_turbulence/#Model-diagnostics","page":"Two-dimensional turbulence","title":"Model diagnostics","text":"Up until now we have only used Oceananigans, but we can make use of Oceanostics for the first diagnostic we'll set-up: a progress messenger. Here we use a BasicMessenger, which, as the name suggests, displays basic information about the simulation\n\nusing Oceanostics\n\nprogress = ProgressMessengers.BasicMessenger()\n\nsimulation.callbacks[:progress] = Callback(progress, IterationInterval(100))\n\nUsing Oceanostics we can easily calculate two important diagnostics, the kinetic energy KE and its dissipation rate Îµ\n\nKE = KineticEnergyEquation.KineticEnergy(model)\nÎµ = KineticEnergyEquation.DissipationRate(model)\n\nAnd we can define their volume-integrals\n\nâˆ«KE = Integral(KE)\nâˆ«Îµ = Integral(Îµ)\n\nWe also create another integrated quantity that appears in the TKE evolution equation: the KineticEnergyStress, which in our case is\n\nvarepsilon^D = u_i partial_j tau_ij\n\nwhere tau_ij is the diffusive flux of i momentum in the j-th direction.\n\nâˆ«Îµá´° = Integral(KineticEnergyEquation.Stress(model))\n\nThe idea in calculating this term is that, in integrated form, all transport contributions in it should equal zero and âˆ«Îµá´° should equal âˆ«Îµ.\n\nWe output the previous quantities to a NetCDF file\n\noutput_fields = (; KE, Îµ, âˆ«KE, âˆ«Îµ, âˆ«Îµá´°)\n\nusing NCDatasets\nfilename = \"two_dimensional_turbulence\"\nsimulation.output_writers[:nc] = NetCDFWriter(model, output_fields,\n                                              filename = joinpath(@__DIR__, filename),\n                                              schedule = TimeInterval(0.6),\n                                              overwrite_existing = true)","category":"section"},{"location":"generated/two_dimensional_turbulence/#Run-the-simulation-and-process-results","page":"Two-dimensional turbulence","title":"Run the simulation and process results","text":"To run the simulation:\n\nrun!(simulation)\n\nNow we'll read the results using Rasters.jl, which works somewhat similarly to Python's Xarray and can speed-up the workflow\n\nusing Rasters\n\nds = RasterStack(simulation.output_writers[:nc].filepath)\n\nIn order to plot results, we use Makie.jl, for which Rasters.jl already has some recipes\n\nusing CairoMakie\n\nset_theme!(Theme(fontsize = 24))\nfig = Figure()\n\naxis_kwargs = (xlabel = \"x\", ylabel = \"y\",\n               aspect = DataAspect(),\n               height = 300, width = 300)\n\nax1 = Axis(fig[2, 1]; title = \"Kinetic energy\", axis_kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Kinetic energy dissip rate\", axis_kwargs...)\n\nNow we plot the snapshots and set the title\n\nn = Observable(1)\n\nn above is a Makie.Observable, which allows us to animate things easily. Creating observable KE and Îµ can be done simply with\n\nKEâ‚™ = @lift set(ds.KE[z_aac=1, Ti=$n], :x_caa => X, :y_aca => Y);\nÎµâ‚™  = @lift set(ds.Îµ[z_aac=1, Ti=$n],  :x_caa => X, :y_aca => Y);\nnothing #hide\n\nNote that, in Rasters, the time coordinate gets shortened to Ti.\n\nNow we plot the heatmaps, each with its own colorbar below\n\nhm_KE = heatmap!(ax1, KEâ‚™, colormap = :plasma, colorrange=(0, 5e-2))\nColorbar(fig[3, 1], hm_KE; vertical=false, height=8, ticklabelsize=12)\n\nhm_Îµ = heatmap!(ax2, Îµâ‚™, colormap = :inferno, colorrange=(0, 5e-5))\nColorbar(fig[3, 2], hm_Îµ; vertical=false, height=8, ticklabelsize=12)\n\nWe now plot the time evolution of our integrated quantities\n\naxis_kwargs = (xlabel = \"Time\",\n               height=150, width=300)\n\nax3 = Axis(fig[4, 1]; axis_kwargs...)\ntimes = dims(ds, :Ti)\nlines!(ax3, Array(times), Array(ds.âˆ«KE))\n\nax4 = Axis(fig[4, 2]; axis_kwargs...)\nlines!(ax4, Array(times), Array(ds.âˆ«Îµ), label=\"âˆ«ÎµdV\")\nlines!(ax4, Array(times), Array(ds.âˆ«Îµá´°), label=\"âˆ«Îµá´°dV\", linestyle=:dash)\naxislegend(ax4, labelsize=14)\n\nNow we mark the time by placing a vertical line in the bottom plots:\n\ntâ‚™ = @lift times[$n]\nvlines!(ax3, tâ‚™, color=:black, linestyle=:dash)\nvlines!(ax4, tâ‚™, color=:black, linestyle=:dash)\n\nand by creating a useful title\n\ntitle = @lift \"Time = \" * string(round(times[$n], digits=2))\nLabel(fig[1, 1:2], title, fontsize=24, tellwidth=false);\nnothing #hide\n\nNext we adjust the total figure size based on our panels, which makes it look like this\n\nresize_to_layout!(fig)\ncurrent_figure() # hide\nfig\n\nFinally, we record a movie.\n\n@info \"Animating...\"\nrecord(fig, filename * \".mp4\", 1:length(times), framerate=24) do i\n    n[] = i\nend\nnothing #hide\n\n(Image: )\n\nAlthough simple, this example and the animation above already illustrate a couple of interesting things. First, the KE dissipation rate Îµ is distributed at much smaller scales than the KE, which is expected due to the second-order derivatives present in Îµ.\n\nSecond, again as expected, the volume-integrated KE dissipation rate is the same as the volume-integrated KE diffusion term (since all the non-dissipation parts of the term volume-integrate to zero). In fact, both KineticEnergyDissipationRate and KineticEnergyStress in Oceanostics are implemented in an energy-conserving form (i.e., they use the exact same discretization scheme and interpolations as used in Oceananigans), so they agree to machine-precision, and are great for closing budgets.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"README.md\"))\n\nnote: âš ï¸ Under construction! ðŸ—ï¸\nWe are still actively working on these docs. If you see any errors or if you have any helpful suggestions please open an issue or a pull request on github.","category":"section"},{"location":"#Quick-example","page":"Home","title":"Quick example","text":"The example below illustrates a few of Oceanostics' features. Check the Examples for more detailed usage.\n\njulia> using Oceananigans\n\njulia> using Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 5, 6), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid, closure=SmagorinskyLilly());\n\njulia> simulation = Simulation(model, Î”t=1, stop_time=10);\n\njulia> simulation.callbacks[:progress] = Callback(ProgressMessengers.TimedMessenger(), IterationInterval(5));\n\njulia> ke = KineticEnergyEquation.KineticEnergy(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—5Ã—6 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: kinetic_energy_ccc (generic function with 1 method)\nâ””â”€â”€ arguments: (\"Field\", \"Field\", \"Field\")\n\njulia> Îµ = KineticEnergyEquation.KineticEnergyDissipationRate(model)\nKernelFunctionOperation at (Center, Center, Center)\nâ”œâ”€â”€ grid: 4Ã—5Ã—6 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3Ã—3Ã—3 halo\nâ”œâ”€â”€ kernel_function: viscous_dissipation_rate_ccc (generic function with 1 method)\nâ””â”€â”€ arguments: (\"NamedTuple\", \"NamedTuple\", \"NamedTuple\")\n\njulia> run!(simulation)\n[ Info: Initializing simulation...\nâ”Œ Info: iter =      0,  [000.00%] time = 0 seconds,  Î”t = 1 second,  walltime = 621.022 ms,  walltime / timestep = 0 seconds\nâ””           |uâƒ—|â‚˜â‚â‚“ = [0.00e+00,  0.00e+00,  0.00e+00] m/s,  advective CFL = 0,  diffusive CFL = 0,  Î½â‚˜â‚â‚“ = 0 mÂ²/s\n[ Info:     ... simulation initialization complete (8.970 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (3.415 ms).\nâ”Œ Info: iter =      5,  [050.00%] time = 5 seconds,  Î”t = 1 second,  walltime = 9.035 seconds,  walltime / timestep = 1.683 seconds\nâ””           |uâƒ—|â‚˜â‚â‚“ = [0.00e+00,  0.00e+00,  0.00e+00] m/s,  advective CFL = 0,  diffusive CFL = 0,  Î½â‚˜â‚â‚“ = 0 mÂ²/s\n[ Info: Simulation is stopping after running for 9.030 seconds.\n[ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.\nâ”Œ Info: iter =     10,  [100.00%] time = 10 seconds,  Î”t = 1 second,  walltime = 9.052 seconds,  walltime / timestep = 3.340 ms\nâ””           |uâƒ—|â‚˜â‚â‚“ = [0.00e+00,  0.00e+00,  0.00e+00] m/s,  advective CFL = 0,  diffusive CFL = 0,  Î½â‚˜â‚â‚“ = 0 mÂ²/s","category":"section"}]
}
