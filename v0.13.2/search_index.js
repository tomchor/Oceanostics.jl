var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"EditURL = \"../../examples/kelvin_helmholtz.jl\"","category":"page"},{"location":"generated/kelvin_helmholtz/#Kelvin-Helmholtz-instability","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"","category":"section"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"This example simulates a simple 2D Kelvin-Helmholtz instability and is based on the similar Oceananigans example.","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Before starting, make sure you have the required packages installed for this example, which can be done with","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using Pkg\npkg\"add Oceananigans, Oceanostics, CairoMakie, Rasters\"","category":"page"},{"location":"generated/kelvin_helmholtz/#Model-and-simulation-setup","page":"Kelvin-Helmholtz instability","title":"Model and simulation setup","text":"","category":"section"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We begin by creating a model with an isotropic diffusivity and fifth-order advection on a xz 128² grid using a buoyancy b as the active scalar. We'll work here with nondimensional quantities.","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using Oceananigans\n\nN = 128\nL = 10\ngrid = RectilinearGrid(size=(N, N), x=(-L/2, +L/2), z=(-L/2, +L/2), topology=(Periodic, Flat, Bounded))\n\nmodel = NonhydrostaticModel(; grid, timestepper = :RungeKutta3,\n                            advection = UpwindBiasedFifthOrder(),\n                            closure = ScalarDiffusivity(ν=2e-5, κ=2e-5),\n                            buoyancy = BuoyancyTracer(), tracers = :b)","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We use hyperbolic tangent functions for the initial conditions and set the maximum Richardson number below the threshold of 1/4. We also add some grid-scale small-amplitude noise to u to kick the instability off:","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"noise(x, z) = 2e-2 * randn()\nshear_flow(x, z) = tanh(z) + noise(x, z)\n\nRi₀ = 0.1; h = 1/4\nstratification(x, z) = h * Ri₀ * tanh(z / h)\n\nset!(model, u=shear_flow, b=stratification)","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Next create an adaptive-time-step simulation using the model above:","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"simulation = Simulation(model, Δt=0.1, stop_time=100)\n\nwizard = TimeStepWizard(cfl=0.8, max_Δt=1)\nsimulation.callbacks[:wizard] = Callback(wizard, IterationInterval(2))","category":"page"},{"location":"generated/kelvin_helmholtz/#Model-diagnostics","page":"Kelvin-Helmholtz instability","title":"Model diagnostics","text":"","category":"section"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We set-up a progress messenger using the TimedMessenger, which displays, among other information, the time step duration","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using Oceanostics\n\nprogress = ProgressMessengers.TimedMessenger()\nsimulation.callbacks[:progress] = Callback(progress, IterationInterval(200))","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We can also define some useful diagnostics for of the flow, starting with the RichardsonNumber","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Ri = RichardsonNumber(model)","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We also set-up the QVelocityGradientTensorInvariant, which is usually used for visualizing vortices in the flow:","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Q = QVelocityGradientTensorInvariant(model)","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Q is one of the velocity gradient tensor invariants and it measures the amount of vorticity versus the strain in the flow and, when it's positive, indicates a vortex. This method of vortex visualization is called the Q-criterion.","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Let's also keep track of the amount of buoyancy mixing by measuring the buoyancy variance dissipation rate and diffusive term. When volume-integrated, these two quantities should be equal.","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"∫χᴰ = Integral(TracerVarianceDissipationRate(model, :b))\n∫χ = Integral(TracerVarianceDiffusiveTerm(model, :b))","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Now we write these quantities, along with b, to a NetCDF:","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"output_fields = (; Ri, Q, model.tracers.b, ∫χ, ∫χᴰ)\nfilename = \"kelvin_helmholtz\"\nsimulation.output_writers[:nc] = NetCDFOutputWriter(model, output_fields,\n                                                    filename = joinpath(@__DIR__, filename),\n                                                    schedule = TimeInterval(1),\n                                                    overwrite_existing = true)","category":"page"},{"location":"generated/kelvin_helmholtz/#Run-the-simulation-and-process-results","page":"Kelvin-Helmholtz instability","title":"Run the simulation and process results","text":"","category":"section"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"To run the simulation:","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"run!(simulation)","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Now we'll read the results using Rasters.jl, which works somewhat similarly to Python's Xarray and can speed-up the work the workflow","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using Rasters\n\nds = RasterStack(simulation.output_writers[:nc].filepath)","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We now use Makie to create the figure and its axes","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"using CairoMakie\n\nset_theme!(Theme(fontsize = 24))\nfig = Figure()\n\nkwargs = (xlabel=\"x\", ylabel=\"z\", height=150, width=250)\nax1 = Axis(fig[2, 1]; title = \"Ri\", kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Q\", kwargs...)\nax3 = Axis(fig[2, 3]; title = \"b\", kwargs...);\nnothing #hide","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Next we use Observables to lift the values and plot heatmaps and their colorbars","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"n = Observable(1)\n\nRiₙ = @lift set(ds.Ri[Ti=$n, yC=Near(0)], :xC => X, :zF => Z)\nhm1 = heatmap!(ax1, Riₙ; colormap = :bwr, colorrange = (-1, +1))\nColorbar(fig[3, 1], hm1, vertical=false, height=8)\n\nQₙ = @lift set(ds.Q[Ti=$n, yC=Near(0)], :xC => X, :zC => Z)\nhm2 = heatmap!(ax2, Qₙ; colormap = :inferno, colorrange = (0, 0.2))\nColorbar(fig[3, 2], hm2, vertical=false, height=8)\n\nbₙ = @lift set(ds.b[Ti=$n, yC=Near(0)], :xC => X, :zC => Z)\nhm3 = heatmap!(ax3, bₙ; colormap = :balance, colorrange = (-2.5e-2, +2.5e-2))\nColorbar(fig[3, 3], hm3, vertical=false, height=8);\nnothing #hide","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"We now plot the time evolution of our integrated quantities","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"axb = Axis(fig[4, 1:3]; xlabel=\"Time\", height=100)\ntimes = dims(ds, :Ti)\nlines!(axb, Array(times), ds.∫χ,  label = \"∫χdV\")\nlines!(axb, Array(times), ds.∫χᴰ, label = \"∫χᴰdV\", linestyle=:dash)\naxislegend(position=:lb, labelsize=14)","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Now we mark the time by placing a vertical line in the bottom panel and adding a helpful title","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"tₙ = @lift times[$n]\nvlines!(axb, tₙ, color=:black, linestyle=:dash)\n\ntitle = @lift \"Time = \" * string(round(times[$n], digits=2))\nfig[1, 1:3] = Label(fig, title, fontsize=24, tellwidth=false);\nnothing #hide","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Finally, we adjust the figure dimensions to fit all the panels and record a movie","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"resize_to_layout!(fig)\n\n@info \"Animating...\"\nrecord(fig, filename * \".mp4\", 1:length(times), framerate=10) do i\n       n[] = i\nend","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"(Image: )","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"Similarly to the kinetic energy dissipation rate (see the Two-dimensional turbulence example), TracerVarianceDissipationRate and TracerVarianceDiffusiveTerm are implemented with a energy-conserving formulation, which means that (for NoFlux boundary conditions) their volume-integral should be exactly (up to machine precision) the same.","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"","category":"page"},{"location":"generated/kelvin_helmholtz/","page":"Kelvin-Helmholtz instability","title":"Kelvin-Helmholtz instability","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"EditURL = \"../../examples/tilted_bottom_boundary_layer.jl\"","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/#Tilted-bottom-boundary-layer-example","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer example","text":"","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"This example is based on the similar Oceananigans example and simulates a two-dimensional oceanic bottom boundary layer in a domain that's tilted with respect to gravity. We simulate the perturbation away from a constant along-slope (y-direction) velocity constant density stratification.  This perturbation develops into a turbulent bottom boundary layer due to momentum loss at the bottom boundary.","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using Pkg\npkg\"add Oceananigans, Oceanostics, Rasters, CairoMakie\"","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/#Grid","page":"Tilted bottom boundary layer","title":"Grid","text":"","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We start by creating a x z grid with 64² cells:","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using Oceananigans\nusing Oceananigans.Units\n\nLx = 200meters\nLz = 100meters\nNx = 64\nNz = 64\n\ngrid = RectilinearGrid(topology = (Periodic, Flat, Bounded), size = (Nx, Nz),\n                       x = (0, Lx), z = (0, Lz))","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/#Tilting-the-domain","page":"Tilted bottom boundary layer","title":"Tilting the domain","text":"","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We use a domain that's tilted with respect to gravity by","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"θ = 5; # degrees\nnothing #hide","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"so that x is the along-slope direction, z is the across-sloce direction that is perpendicular to the bottom, and the unit vector anti-aligned with gravity is","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"ĝ = [sind(θ), 0, cosd(θ)]","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Changing the vertical direction impacts both the gravity_unit_vector for Buoyancy as well as the rotation_axis for Coriolis forces,","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"buoyancy = Buoyancy(model = BuoyancyTracer(), gravity_unit_vector = -ĝ)\n\nf₀ = 1e-4/second\ncoriolis = ConstantCartesianCoriolis(f = f₀, rotation_axis = ĝ)","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"The tilting also affects the kind of density stratified flows we can model. The simulate an environment that's uniformly stratified, with a stratification frequency","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"N² = 1e-5/second^2;\nnothing #hide","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"In a tilted coordinate, this can be achieved with","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"@inline constant_stratification(x, z, t, p) = p.N² * (x * p.ĝ[1] + z * p.ĝ[3]);\nnothing #hide","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"However, this distribution is not periodic in x and can't be explicitly modelled on an x-periodic grid such as the one used here. Instead, we simulate periodic perturbations away from the constant density stratification by imposing a constant stratification as a BackgroundField,","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"B_field = BackgroundField(constant_stratification, parameters=(; ĝ, N²))","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/#Bottom-drag","page":"Tilted bottom boundary layer","title":"Bottom drag","text":"","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We impose bottom drag that follows Monin-Obukhov theory and include the background flow in the drag calculation, which is the only effect the background flow has on the problem","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"V∞ = 0.1meters/second\nz₀ = 0.1meters # (roughness length)\nκ = 0.4 # von Karman constant\nz₁ = znodes(grid, Center())[1] # Closest grid center to the bottom\ncᴰ = (κ / log(z₁ / z₀))^2 # Drag coefficient\n\n@inline drag_u(x, t, u, v, p) = - p.cᴰ * √(u^2 + (v + p.V∞)^2) * u\n@inline drag_v(x, t, u, v, p) = - p.cᴰ * √(u^2 + (v + p.V∞)^2) * (v + p.V∞)\n\ndrag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰ, V∞))\ndrag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰ, V∞))\n\nu_bcs = FieldBoundaryConditions(bottom = drag_bc_u)\nv_bcs = FieldBoundaryConditions(bottom = drag_bc_v)","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/#Create-model-and-simulation","page":"Tilted bottom boundary layer","title":"Create model and simulation","text":"","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We are now ready to create the model. We create a NonhydrostaticModel with an UpwindBiasedFifthOrder advection scheme, a RungeKutta3 timestepper, and a constant viscosity and diffusivity.","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"closure = ScalarDiffusivity(ν=2e-4, κ=2e-4)\n\nmodel = NonhydrostaticModel(; grid, buoyancy, coriolis, closure,\n                            timestepper = :RungeKutta3,\n                            advection = UpwindBiasedFifthOrder(),\n                            tracers = :b,\n                            boundary_conditions = (u=u_bcs, v=v_bcs),\n                            background_fields = (; b=B_field))\n\nnoise(x, z) = 1e-3 * randn() * exp(-(10z)^2/grid.Lz^2)\nset!(model, u=noise, w=noise)","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"The bottom-intensified noise above should accelerate the emergence of turbulence close to the wall.","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We are now ready to create the simulation. We begin by setting the initial time step conservatively, based on the smallest grid size of our domain and set-up a","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using Oceananigans.Units\n\nsimulation = Simulation(model, Δt = 0.5 * minimum_zspacing(grid) / V∞, stop_time = 12hours)","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We use TimeStepWizard to maximize Δt","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"wizard = TimeStepWizard(max_change=1.1, cfl=0.7)\nsimulation.callbacks[:wizard] = Callback(wizard, IterationInterval(4))","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/#Model-diagnostics","page":"Tilted bottom boundary layer","title":"Model diagnostics","text":"","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We set-up a custom progress messenger using Oceanostics.ProgressMessengers, which allows us to combine different ProgressMessengers into one:","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using Oceanostics.ProgressMessengers\n\nwalltime_per_timestep = StepDuration() # This needs to instantiated here, and not in the function below\nprogress(simulation) = @info (PercentageProgress(with_prefix=false, with_units=false) + SimulationTime() + TimeStep() + MaxVelocities() + AdvectiveCFLNumber() + walltime_per_timestep)(simulation)\n\nsimulation.callbacks[:progress] = Callback(progress, IterationInterval(400))","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We now define some useful diagnostics for the flow. Namely, we define RichardsonNumber, RossbyNumber and ErtelPotentialVorticity:","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using Oceanostics\n\nRi = RichardsonNumber(model, add_background=true)\nRo = RossbyNumber(model)\nPV = ErtelPotentialVorticity(model, add_background=true)","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Note that the calculation of these quantities depends on the alignment with the true (geophysical) vertical and the rotation axis. Oceanostics already takes that into consideration by using model.buoyancy and model.coriolis, making their calculation much easier. Furthermore, passing the flag add_background=true automatically adds the model's BackgroundFields to the resolved perturbations, which is important in our case for the correct calculation of nabla b with the background stratification.","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Now we write these quantities to a NetCDF file:","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"output_fields = (; Ri, Ro, PV, b = model.tracers.b + model.background_fields.tracers.b)\n\nfilename = \"tilted_bottom_boundary_layer\"\nsimulation.output_writers[:nc] = NetCDFOutputWriter(model, output_fields,\n                                                    filename = joinpath(@__DIR__, filename),\n                                                    schedule = TimeInterval(20minutes),\n                                                    overwrite_existing = true)","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/#Run-the-simulation-and-process-results","page":"Tilted bottom boundary layer","title":"Run the simulation and process results","text":"","category":"section"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"To run the simulation:","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"run!(simulation)","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Now we'll read the results and plot an animation","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using Rasters\n\nds = RasterStack(simulation.output_writers[:nc].filepath)","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"We now use Makie to create the figure and its axes","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"using CairoMakie\n\nset_theme!(Theme(fontsize = 20))\nfig = Figure()\n\nkwargs = (xlabel=\"x\", ylabel=\"z\", height=150, width=250)\nax1 = Axis(fig[2, 1]; title = \"Ri\", kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Ro\", kwargs...)\nax3 = Axis(fig[2, 3]; title = \"PV\", kwargs...);\nnothing #hide","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Next we an Observable to lift the values at each specific time and plot heatmaps, along with their colorbars, with buoyancy contours on top","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"n = Observable(1)\n\nbₙ = @lift set(ds.b[Ti=$n, yC=Near(0)], :xC => X, :zC => Z)\n\nRiₙ = @lift set(ds.Ri[Ti=$n, yC=Near(0)], :xC => X, :zF => Z)\nhm1 = heatmap!(ax1, Riₙ; colormap = :coolwarm, colorrange = (-1, +1))\ncontour!(ax1, bₙ; levels=10, color=:white, linestyle=:dash, linewidth=0.5)\nColorbar(fig[3, 1], hm1, vertical=false, height=8, ticklabelsize=14)\n\nRoₙ = @lift set(ds.Ro[Ti=$n, yF=Near(0)], :xF => X, :zF => Z)\nhm2 = heatmap!(ax2, Roₙ; colormap = :balance, colorrange = (-10, +10))\ncontour!(ax2, bₙ; levels=10, color=:black, linestyle=:dash, linewidth=0.5)\nColorbar(fig[3, 2], hm2, vertical=false, height=8, ticklabelsize=14)\n\nPVₙ = @lift set(ds.PV[Ti=$n, yF=Near(0)], :xF => X, :zF => Z)\nhm3 = heatmap!(ax3, PVₙ; colormap = :coolwarm, colorrange = N²*f₀.*(-1.5, +1.5))\ncontour!(ax3, bₙ; levels=10, color=:white, linestyle=:dash, linewidth=0.5)\nColorbar(fig[3, 3], hm3, vertical=false, height=8, ticklabelsize=14);\nnothing #hide","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Now we mark the time by placing a vertical line in the bottom panel and adding a helpful title","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"times = dims(ds, :Ti)\ntitle = @lift \"Time = \" * string(prettytime(times[$n]))\nfig[1, 1:3] = Label(fig, title, fontsize=24, tellwidth=false);\nnothing #hide","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"Finally, we adjust the figure dimensions to fit all the panels and record a movie","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"resize_to_layout!(fig)\n\n@info \"Animating...\"\nrecord(fig, filename * \".mp4\", 1:length(times), framerate=10) do i\n       n[] = i\nend","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"(Image: )","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"The animation shows negative PV being produced at the bottom due to drag, which leads to the emergence of centrifulgal-symmetric instabilities, which become turbulent and erode stratification (as can be seen by inspecting Ri). Note that there are some boundary effects on the upper boundary, likely caused by interaction internal waves that are produced by the bottom turbulence. These effects are, to some degree, expected, and a sponge/relaxation layer at the top is needed to minimize them in a production-ready code.","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"","category":"page"},{"location":"generated/tilted_bottom_boundary_layer/","page":"Tilted bottom boundary layer","title":"Tilted bottom boundary layer","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/#Library","page":"Function library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Function library","title":"Function library","text":"Documentation for the public user interface.","category":"page"},{"location":"library/#Oceanostics.jl","page":"Function library","title":"Oceanostics.jl","text":"","category":"section"},{"location":"library/","page":"Function library","title":"Function library","text":"Modules = [Oceanostics]\nPrivate = false","category":"page"},{"location":"library/#Oceanostics.TKEBudgetTerms","page":"Function library","title":"Oceanostics.TKEBudgetTerms","text":"","category":"section"},{"location":"library/","page":"Function library","title":"Function library","text":"Modules = [Oceanostics.TKEBudgetTerms]\nPrivate = false","category":"page"},{"location":"library/#Oceanostics.TKEBudgetTerms.IsotropicKineticEnergyDissipationRate-Tuple{Any}","page":"Function library","title":"Oceanostics.TKEBudgetTerms.IsotropicKineticEnergyDissipationRate","text":"IsotropicKineticEnergyDissipationRate(\n    model;\n    U,\n    V,\n    W,\n    location\n)\n\n\nCalculate the Viscous Dissipation Rate, defined as\n\nε = 2 ν SᵢⱼSᵢⱼ,\n\nwhere Sᵢⱼ is the strain rate tensor, for a fluid with an isotropic turbulence closure (i.e., a  turbulence closure where ν (eddy or not) is the same for all directions.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TKEBudgetTerms.KineticEnergy-NTuple{4, Any}","page":"Function library","title":"Oceanostics.TKEBudgetTerms.KineticEnergy","text":"KineticEnergy(model, u, v, w; location, kwargs...)\n\n\nCalculate the kinetic energy of model manually specifying u, v and w.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TKEBudgetTerms.KineticEnergy-Tuple{Any}","page":"Function library","title":"Oceanostics.TKEBudgetTerms.KineticEnergy","text":"KineticEnergy(model; kwargs...)\n\n\nCalculate the kinetic energy of model.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TKEBudgetTerms.KineticEnergyDiffusiveTerm-Tuple{Any}","page":"Function library","title":"Oceanostics.TKEBudgetTerms.KineticEnergyDiffusiveTerm","text":"KineticEnergyDiffusiveTerm(model; location)\n\n\nReturn a KernelFunctionOperation that computes the diffusive term of the KE prognostic equation:\n\n    DIFF = uᵢ∂ⱼτᵢⱼ\n\nwhere uᵢ are the velocity components and τᵢⱼ is the diffusive flux of i momentum in the  j-th direction.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TKEBudgetTerms.KineticEnergyDissipationRate-Tuple{Any}","page":"Function library","title":"Oceanostics.TKEBudgetTerms.KineticEnergyDissipationRate","text":"KineticEnergyDissipationRate(model; U, V, W, location)\n\n\nCalculate the pseudo viscous Dissipation Rate, defined as\n\nε = ν (∂uᵢ/∂xⱼ) (∂uᵢ/∂xⱼ)\n\nfor a fluid with an isotropic turbulence closure (i.e., a  turbulence closure where ν (eddy or not) is the same for all directions.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TKEBudgetTerms.KineticEnergyForcingTerm-Tuple{NonhydrostaticModel}","page":"Function library","title":"Oceanostics.TKEBudgetTerms.KineticEnergyForcingTerm","text":"KineticEnergyForcingTerm(model; location)\n\n\nReturn a KernelFunctionOperation that computes the forcing term of the KE prognostic equation:\n\n    FORC = uᵢFᵤᵢ\n\nwhere uᵢ are the velocity components and Fᵤᵢ is the forcing term(s) in the uᵢ prognostic equation (i.e. the forcing for uᵢ).\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TKEBudgetTerms.KineticEnergyTendency-Tuple{NonhydrostaticModel}","page":"Function library","title":"Oceanostics.TKEBudgetTerms.KineticEnergyTendency","text":"KineticEnergyTendency(model; location)\n\n\nReturn a KernelFunctionOperation that computes the tendency of the KE except for the nonhydrostatic pressure:\n\n\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TKEBudgetTerms.TurbulentKineticEnergy-NTuple{4, Any}","page":"Function library","title":"Oceanostics.TKEBudgetTerms.TurbulentKineticEnergy","text":"TurbulentKineticEnergy(model, u, v, w; U, V, W, location)\n\n\nCalculate the turbulent kinetic energy of model manually specifying u, v, w and optionally background velocities U, V and W.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TKEBudgetTerms.TurbulentKineticEnergy-Tuple{Any}","page":"Function library","title":"Oceanostics.TKEBudgetTerms.TurbulentKineticEnergy","text":"TurbulentKineticEnergy(model; kwargs...)\n\n\nCalculate the turbulent kinetic energy of model.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TKEBudgetTerms.XPressureRedistribution-Tuple{Any, Any, Any}","page":"Function library","title":"Oceanostics.TKEBudgetTerms.XPressureRedistribution","text":"XPressureRedistribution(model, u′, p′)\n\n\nCalculate the pressure redistribution term in the x direction. Here u′ and p′ are the fluctuations around a mean.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TKEBudgetTerms.XShearProductionRate-NTuple{7, Any}","page":"Function library","title":"Oceanostics.TKEBudgetTerms.XShearProductionRate","text":"XShearProductionRate(model, u, v, w, U, V, W; location)\n\n\nCalculate the shear production rate in the model's x direction, considering velocities u, v, w and background (or average) velocities U, V and W.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TKEBudgetTerms.XShearProductionRate-Tuple{Any}","page":"Function library","title":"Oceanostics.TKEBudgetTerms.XShearProductionRate","text":"XShearProductionRate(model; U, V, W, kwargs...)\n\n\nCalculate the shear production rate in the model's x direction. At least one of the mean  velocities U, V and W must be specified otherwise the output will be zero.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TKEBudgetTerms.YPressureRedistribution-Tuple{Any, Any, Any}","page":"Function library","title":"Oceanostics.TKEBudgetTerms.YPressureRedistribution","text":"YPressureRedistribution(model, v′, p′)\n\n\nCalculate the pressure redistribution term in the y direction. Here v′ and p′ are the fluctuations around a mean.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TKEBudgetTerms.YShearProductionRate-NTuple{7, Any}","page":"Function library","title":"Oceanostics.TKEBudgetTerms.YShearProductionRate","text":"YShearProductionRate(model, u, v, w, U, V, W; location)\n\n\nCalculate the shear production rate in the model's y direction, considering velocities u, v, w and background (or average) velocities U, V and W.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TKEBudgetTerms.YShearProductionRate-Tuple{Any}","page":"Function library","title":"Oceanostics.TKEBudgetTerms.YShearProductionRate","text":"YShearProductionRate(model; U, V, W, kwargs...)\n\n\nCalculate the shear production rate in the model's y direction. At least one of the mean  velocities U, V and W must be specified otherwise the output will be zero.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TKEBudgetTerms.ZPressureRedistribution-Tuple{Any, Any, Any}","page":"Function library","title":"Oceanostics.TKEBudgetTerms.ZPressureRedistribution","text":"ZPressureRedistribution(model, w′, p′)\n\n\nCalculate the pressure redistribution term in the z direction. Here w′ and p′ are the fluctuations around a mean.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TKEBudgetTerms.ZShearProductionRate-NTuple{7, Any}","page":"Function library","title":"Oceanostics.TKEBudgetTerms.ZShearProductionRate","text":"ZShearProductionRate(model, u, v, w, U, V, W; location)\n\n\nCalculate the shear production rate in the model's z direction, considering velocities u, v, w and background (or average) velocities U, V and W.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TKEBudgetTerms.ZShearProductionRate-Tuple{Any}","page":"Function library","title":"Oceanostics.TKEBudgetTerms.ZShearProductionRate","text":"ZShearProductionRate(model; U, V, W, kwargs...)\n\n\nCalculate the shear production rate in the model's z direction. At least one of the mean  velocities U, V and W must be specified otherwise the output will be zero.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TracerVarianceBudgetTerms","page":"Function library","title":"Oceanostics.TracerVarianceBudgetTerms","text":"","category":"section"},{"location":"library/","page":"Function library","title":"Function library","text":"Modules = [Oceanostics.TracerVarianceBudgetTerms]\nPrivate = false","category":"page"},{"location":"library/#Oceanostics.TracerVarianceBudgetTerms.TracerVarianceDiffusiveTerm-Tuple{Any, Any}","page":"Function library","title":"Oceanostics.TracerVarianceBudgetTerms.TracerVarianceDiffusiveTerm","text":"TracerVarianceDiffusiveTerm(model, tracer_name; location)\n\n\nReturn a KernelFunctionOperation that computes the diffusive term of the tracer variance prognostic equation using Oceananigans' diffusive tracer flux divergence kernel:\n\n    DIFF = 2 c ∂ⱼFⱼ\n\nwhere c is the tracer, and Fⱼ is the tracer's diffusive flux in the j-th direction.\n\ngrid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, tracers=:b, closure=SmagorinskyLilly())\n\nDIFF = TracerVarianceDiffusiveTerm(model, :b)\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TracerVarianceBudgetTerms.TracerVarianceDissipationRate-Tuple{Any, Any}","page":"Function library","title":"Oceanostics.TracerVarianceBudgetTerms.TracerVarianceDissipationRate","text":"TracerVarianceDissipationRate(\n    model,\n    tracer_name;\n    tracer,\n    location\n)\n\n\nReturn a KernelFunctionOperation that computes the isotropic variance dissipation rate for tracer_name in model.tracers. The isotropic variance dissipation rate is defined as \n\n    χ = 2 ∂ⱼc ⋅ Fⱼ\n\nwhere Fⱼ is the diffusive flux of c in the j-th direction and ∂ⱼ is the gradient operator. χ is implemented in its conservative formulation based on the equation above. \n\nNote that often χ is written as χ = 2κ (∇c ⋅ ∇c), which is the special case for Fickian diffusion (κ is the tracer diffusivity).\n\nHere tracer_name is needed even when passing tracer in order to get the appropriate tracer_index. When passing tracer, this function should be used as\n\ngrid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, tracers=:b, closure=SmagorinskyLilly())\n\nb̄ = Field(Average(model.tracers.b, dims=(1,2)))\nb′ = model.tracers.b - b̄\n\nχb = TracerVarianceDissipationRate(model, :b, tracer=b′)\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.TracerVarianceBudgetTerms.TracerVarianceTendency-Tuple{NonhydrostaticModel, Any}","page":"Function library","title":"Oceanostics.TracerVarianceBudgetTerms.TracerVarianceTendency","text":"TracerVarianceTendency(model, tracer_name; location)\n\n\nReturn a KernelFunctionOperation that computes the tracer variance tendency:\n\nTEND = 2 c ∂ₜc\n\nwhere c is the tracer and ∂ₜc is the tracer tendency (computed using Oceananigans' tracer tendency kernel).\n\ngrid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1))\nmodel = NonhydrostaticModel(grid=grid, tracers=:b, closure=SmagorinskyLilly())\n\nDIFF = TracerVarianceTendency(model, :b)\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics","page":"Function library","title":"Oceanostics.FlowDiagnostics","text":"","category":"section"},{"location":"library/","page":"Function library","title":"Function library","text":"Modules = [Oceanostics.FlowDiagnostics]\nPrivate = false","category":"page"},{"location":"library/#Oceanostics.FlowDiagnostics.DirectionalErtelPotentialVorticity-Tuple{Any, Any}","page":"Function library","title":"Oceanostics.FlowDiagnostics.DirectionalErtelPotentialVorticity","text":"DirectionalErtelPotentialVorticity(\n    model,\n    direction;\n    location\n)\n\n\nCalculate the contribution from a given direction to the Ertel Potential Vorticity basde on a model and a direction. The Ertel Potential Vorticity is defined as\n\nEPV = ωₜₒₜ ⋅ ∇b\n\nwhere ωₜₒₜ is the total (relative + planetary) vorticity vector, b is the buoyancy and ∇ is the gradient operator.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics.ErtelPotentialVorticity-Tuple{Any}","page":"Function library","title":"Oceanostics.FlowDiagnostics.ErtelPotentialVorticity","text":"ErtelPotentialVorticity(model; location, add_background)\n\n\nCalculate the Ertel Potential Vorticty for model, where the characteristics of the Coriolis rotation are taken from model.coriolis. The Ertel Potential Vorticity is defined as\n\nEPV = ωₜₒₜ ⋅ ∇b\n\nwhere ωₜₒₜ is the total (relative + planetary) vorticity vector, b is the buoyancy and ∇ is the gradient operator.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics.QVelocityGradientTensorInvariant-Tuple{Any}","page":"Function library","title":"Oceanostics.FlowDiagnostics.QVelocityGradientTensorInvariant","text":"QVelocityGradientTensorInvariant(model; location)\n\n\nCalculate the value of the Q velocity gradient tensor invariant. This is usually just called Q and it is generally used for identifying and visualizing vortices in fluid flow.\n\nThe definition and nomenclature comes from the equation for the eigenvalues λ of the velocity gradient tensor ∂ⱼuᵢ:\n\n    λ³ + P λ² + Q λ + T = 0\n\nfrom where Q is defined as\n\n    Q = ½ ( ΩᵢⱼΩᵢⱼ - SᵢⱼSᵢⱼ)\n\nand where Sᵢⱼ= ½(∂ⱼuᵢ + ∂ᵢuⱼ) and Ωᵢⱼ= ½(∂ⱼuᵢ - ∂ᵢuⱼ). More info about it can be found in doi:10.1063/1.5124245.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics.RichardsonNumber-Tuple{Any}","page":"Function library","title":"Oceanostics.FlowDiagnostics.RichardsonNumber","text":"RichardsonNumber(model; location, add_background)\n\n\nCalculate the Richardson Number as\n\n    Ri = (∂b/∂z) / (|∂u⃗ₕ/∂z|²)\n\nwhere z is the true vertical direction (ie anti-parallel to gravity).\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics.RossbyNumber-Tuple{Any}","page":"Function library","title":"Oceanostics.FlowDiagnostics.RossbyNumber","text":"RossbyNumber(\n    model;\n    location,\n    add_background,\n    dWdy_bg,\n    dVdz_bg,\n    dUdz_bg,\n    dWdx_bg,\n    dUdy_bg,\n    dVdx_bg\n)\n\n\nCalculate the Rossby number using the vorticity in the rotation axis direction according to model.coriolis. Rossby number is defined as\n\n    Ro = ωᶻ / f\n\nwhere ωᶻ is the vorticity in the Coriolis axis of rotation and f is the Coriolis rotation frequency.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics.StrainRateTensorModulus-Tuple{Any}","page":"Function library","title":"Oceanostics.FlowDiagnostics.StrainRateTensorModulus","text":"StrainRateTensorModulus(model; location)\n\n\nCalculate the modulus (absolute value) of the strain rate tensor S, which is defined as the symmetric part of the velocity gradient tensor:\n\n    Sᵢⱼ = ½(∂ⱼuᵢ + ∂ᵢuⱼ)\n\nIts modulus is then defined (using Einstein summation notation) as\n\n    || Sᵢⱼ || = √( Sᵢⱼ Sᵢⱼ)\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics.ThermalWindPotentialVorticity-Tuple{Any}","page":"Function library","title":"Oceanostics.FlowDiagnostics.ThermalWindPotentialVorticity","text":"ThermalWindPotentialVorticity(model; f, location)\n\n\nCalculate the Potential Vorticty assuming thermal wind balance for model, where the characteristics of the Coriolis rotation are taken from model.coriolis. The Potential Vorticity in this case is defined as\n\n    TWPV = (f + ωᶻ) ∂b/∂z - f ((∂U/∂z)² + (∂V/∂z)²)\n\nwhere f is the Coriolis frequency, ωᶻ is the relative vorticity in the z direction, b is the buoyancy, and ∂U/∂z and ∂V/∂z comprise the thermal wind shear.\n\n\n\n\n\n","category":"method"},{"location":"library/#Oceanostics.FlowDiagnostics.VorticityTensorModulus-Tuple{Any}","page":"Function library","title":"Oceanostics.FlowDiagnostics.VorticityTensorModulus","text":"VorticityTensorModulus(model; location)\n\n\nCalculate the modulus (absolute value) of the vorticity tensor Ω, which is defined as the antisymmetric part of the velocity gradient tensor:\n\n    Ωᵢⱼ = ½(∂ⱼuᵢ - ∂ᵢuⱼ)\n\nIts modulus is then defined (using Einstein summation notation) as\n\n    || Ωᵢⱼ || = √( Ωᵢⱼ Ωᵢⱼ)\n\n\n\n\n\n","category":"method"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"EditURL = \"../../examples/two_dimensional_turbulence.jl\"","category":"page"},{"location":"generated/two_dimensional_turbulence/#two_d_turbulence_example","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence example","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"In this example (based on the homonymous Oceananigans one) we simulate a 2D flow initialized with random noise and observe the flow evolve.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Before starting, make sure you have the required packages installed for this example, which can be done with","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Pkg\npkg\"add Oceananigans, Oceanostics, CairoMakie, Rasters\"","category":"page"},{"location":"generated/two_dimensional_turbulence/#Model-and-simulation-setup","page":"Two-dimensional turbulence","title":"Model and simulation setup","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We begin by creating a model with an isotropic diffusivity and fifth-order advection on a 128² grid.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Oceananigans\n\ngrid = RectilinearGrid(size=(128, 128), extent=(2π, 2π), topology=(Periodic, Periodic, Flat))\n\nmodel = NonhydrostaticModel(; grid, timestepper = :RungeKutta3,\n                            advection = UpwindBiasedFifthOrder(),\n                            closure = ScalarDiffusivity(ν=1e-5))","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Let's give the model zero-mean grid-scale white noise as the initial condition","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Statistics\n\nu, v, w = model.velocities\n\nnoise(x, y) = rand()\nset!(model, u=noise, v=noise)\n\nu .-= mean(u)\nv .-= mean(v)","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We use this model to create a simulation with a TimeStepWizard to maximize the Δt","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"simulation = Simulation(model, Δt=0.2, stop_time=50)\n\nwizard = TimeStepWizard(cfl=0.8, diffusive_cfl=0.8)\nsimulation.callbacks[:wizard] = Callback(wizard, IterationInterval(5))","category":"page"},{"location":"generated/two_dimensional_turbulence/#Model-diagnostics","page":"Two-dimensional turbulence","title":"Model diagnostics","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Up until now we have only used Oceananigans, but we can make use of Oceanostics for the first diagnostic we'll set-up: a progress messenger. Here we use a BasicMessenger, which, as the name suggests, displays basic information about the simulation","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Oceanostics\n\nprogress = ProgressMessengers.BasicMessenger()\n\nsimulation.callbacks[:progress] = Callback(progress, IterationInterval(100))","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Using Oceanostics we can easily calculate two important diagnostics, the kinetic energy KE and its dissipation rate ε","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"KE = KineticEnergy(model)\nε = KineticEnergyDissipationRate(model)","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"And we can define their volume-integrals","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"∫KE = Integral(KE)\n∫ε = Integral(ε)","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We also create another integrated quantity that appears in the TKE evolution equation: the KineticEnergyDiffusiveTerm, which in our case is","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"varepsilon^D = u_i partial_j tau_ij","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"where tau_ij is the diffusive flux of i momentum in the j-th direction.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"∫εᴰ = Integral(KineticEnergyDiffusiveTerm(model))","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"The idea in calculating this term is that, in integrated form, all transport terms should equal zero and ∫εᴰ should equal ∫ε.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We output the previous quantities to a NetCDF file","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"output_fields = (; KE, ε, ∫KE, ∫ε, ∫εᴰ)\nfilename = \"two_dimensional_turbulence\"\nsimulation.output_writers[:nc] = NetCDFOutputWriter(model, output_fields,\n                                                    filename = joinpath(@__DIR__, filename),\n                                                    schedule = TimeInterval(0.6),\n                                                    overwrite_existing = true)","category":"page"},{"location":"generated/two_dimensional_turbulence/#Run-the-simulation-and-process-results","page":"Two-dimensional turbulence","title":"Run the simulation and process results","text":"","category":"section"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"To run the simulation:","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"run!(simulation)","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Now we'll read the results using Rasters.jl, which works somewhat similarly to Python's Xarray and can speed-up the workflow","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using Rasters\n\nds = RasterStack(simulation.output_writers[:nc].filepath)","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"In order to plot results, we use Makie.jl, for which Rasters.jl already has some recipes","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"using CairoMakie\n\nset_theme!(Theme(fontsize = 24))\nfig = Figure()\n\naxis_kwargs = (xlabel = \"x\", ylabel = \"y\",\n               aspect = DataAspect(),\n               height = 300, width = 300)\n\nax1 = Axis(fig[2, 1]; title = \"Kinetic energy\", axis_kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Kinetic energy dissip rate\", axis_kwargs...)","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Now we plot the snapshots and set the title","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"n = Observable(1)","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"n above is a Makie.Observable, which allows us to animate things easily. Creating observable KE and ε can be done simply with","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"KEₙ = @lift set(ds.KE[zC=1, Ti=$n], :xC => X, :yC => Y);\nεₙ  = @lift set(ds.ε[zC=1, Ti=$n],  :xC => X, :yC => Y);\nnothing #hide","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Note that, in Rasters, the time coordinate gets shortened to Ti.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Now we plot the heatmaps, each with its own colorbar below","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"hm_KE = heatmap!(ax1, KEₙ, colormap = :plasma, colorrange=(0, 5e-2))\nColorbar(fig[3, 1], hm_KE; vertical=false, height=8, ticklabelsize=12)\n\nhm_ε = heatmap!(ax2, εₙ, colormap = :inferno, colorrange=(0, 5e-5))\nColorbar(fig[3, 2], hm_ε; vertical=false, height=8, ticklabelsize=12)","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"We now plot the time evolution of our integrated quantities","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"axis_kwargs = (xlabel = \"Time\",\n               height=150, width=300)\n\nax3 = Axis(fig[4, 1]; axis_kwargs...)\ntimes = dims(ds, :Ti)\nlines!(ax3, Array(times), ds.∫KE)\n\nax4 = Axis(fig[4, 2]; axis_kwargs...)\nlines!(ax4, Array(times), ds.∫ε, label=\"∫εdV\")\nlines!(ax4, Array(times), ds.∫εᴰ, label=\"∫εᴰdV\", linestyle=:dash)\naxislegend(ax4, labelsize=14)","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Now we mark the time by placing a vertical line in the bottom plots:","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"tₙ = @lift times[$n]\nvlines!(ax3, tₙ, color=:black, linestyle=:dash)\nvlines!(ax4, tₙ, color=:black, linestyle=:dash)","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"and by creating a useful title","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"title = @lift \"Time = \" * string(round(times[$n], digits=2))\nLabel(fig[1, 1:2], title, fontsize=24, tellwidth=false);\nnothing #hide","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Next we adjust the total figure size based on our panels, which makes it look like this","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"resize_to_layout!(fig)\ncurrent_figure() # hide\nfig","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Finally, we record a movie.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"@info \"Animating...\"\nrecord(fig, filename * \".mp4\", 1:length(times), framerate=24) do i\n    n[] = i\nend\nnothing #hide","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"(Image: )","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Although simple, this example and the animation above already illustrate a couple of interesting things. First, the KE dissipation rate ε is distributed at much smaller scales than the KE, which is expected due to the second-order derivatives present in ε.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"Second, again as expected, the volume-integrated KE dissipation rate is the same as the volume-integrated KE diffusion term (since all the non-dissipation parts of the term volume-integrate to zero). In fact, both KineticEnergyDissipationRate and KineticEnergyDiffusiveTerm in Oceanostics are implemented in an energy-conserving form (i.e., they use the exact same discretization scheme and interpolations as used in Oceananigans), so they agree to machine-precision, and are great for closing budgets.","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"","category":"page"},{"location":"generated/two_dimensional_turbulence/","page":"Two-dimensional turbulence","title":"Two-dimensional turbulence","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"README.md\"))","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: ⚠️ Under construction! 🏗️\nWe are still actively working on these docs. If you see any errors or if you have any helpful suggestions please  open an issue or a pull request on github.","category":"page"},{"location":"#Quick-example","page":"Home","title":"Quick example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The example below illustrates a few of Oceanostics' features. Check the Examples for more detailed usage.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Oceananigans\n\njulia> using Oceanostics\n\njulia> grid = RectilinearGrid(size=(4, 5, 6), extent=(1, 1, 1));\n\njulia> model = NonhydrostaticModel(grid=grid, closure=SmagorinskyLilly());\n\njulia> simulation = Simulation(model, Δt=1, stop_time=10);\n\njulia> simulation.callbacks[:progress] = Callback(ProgressMessengers.TimedMessenger(), IterationInterval(5));\n\njulia> ke = KineticEnergy(model)\nKernelFunctionOperation at (Center, Center, Center)\n├── grid: 4×5×6 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── kernel_function: turbulent_kinetic_energy_ccc (generic function with 1 method)\n└── arguments: (\"4×5×6 Field{Face, Center, Center} on RectilinearGrid on CPU\", \"4×5×6 Field{Center, Face, Center} on RectilinearGrid on CPU\", \"4×5×7 Field{Center, Center, Face} on RectilinearGrid on CPU\", \"0\", \"0\", \"0\")\n\njulia> ε = KineticEnergyDissipationRate(model)\nKernelFunctionOperation at (Center, Center, Center)\n├── grid: 4×5×6 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo\n├── kernel_function: viscous_dissipation_rate_ccc (generic function with 1 method)\n└── arguments: (\"(νₑ=4×5×6 Field{Center, Center, Center} on RectilinearGrid on CPU,)\", \"(u=4×5×6 Field{Face, Center, Center} on RectilinearGrid on CPU, v=4×5×6 Field{Center, Face, Center} on RectilinearGrid on CPU, w=4×5×7 Field{Center, Center, Face} on RectilinearGrid on CPU)\", \"(closure=SmagorinskyLilly: C=0.16, Cb=1.0, Pr=NamedTuple(), clock=Clock(time=0 seconds, iteration=0), buoyancy=Nothing)\")\n\njulia> simulation.output_writers[:netcdf_writer] = NetCDFOutputWriter(model, (; ke, ε), filename=\"out.nc\", schedule=TimeInterval(2));\n\njulia> run!(simulation)\n[ Info: Initializing simulation...\n┌ Info: iter =      0,  [000.00%] time = 0 seconds,  Δt = 1 second,  walltime = 621.022 ms,  walltime / timestep = 0 seconds\n└           |u⃗|ₘₐₓ = [0.00e+00,  0.00e+00,  0.00e+00] m/s,  advective CFL = 0,  diffusive CFL = 0,  νₘₐₓ = 0 m²/s\n[ Info:     ... simulation initialization complete (8.970 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (3.415 ms).\n┌ Info: iter =      5,  [050.00%] time = 5 seconds,  Δt = 1 second,  walltime = 9.035 seconds,  walltime / timestep = 1.683 seconds\n└           |u⃗|ₘₐₓ = [0.00e+00,  0.00e+00,  0.00e+00] m/s,  advective CFL = 0,  diffusive CFL = 0,  νₘₐₓ = 0 m²/s\n[ Info: Simulation is stopping after running for 9.030 seconds.\n[ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.\n┌ Info: iter =     10,  [100.00%] time = 10 seconds,  Δt = 1 second,  walltime = 9.052 seconds,  walltime / timestep = 3.340 ms\n└           |u⃗|ₘₐₓ = [0.00e+00,  0.00e+00,  0.00e+00] m/s,  advective CFL = 0,  diffusive CFL = 0,  νₘₐₓ = 0 m²/s","category":"page"}]
}
