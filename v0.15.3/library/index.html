<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function library ¬∑ Oceanostics.jl</title><meta name="title" content="Function library ¬∑ Oceanostics.jl"/><meta property="og:title" content="Function library ¬∑ Oceanostics.jl"/><meta property="twitter:title" content="Function library ¬∑ Oceanostics.jl"/><meta name="description" content="Documentation for Oceanostics.jl."/><meta property="og:description" content="Documentation for Oceanostics.jl."/><meta property="twitter:description" content="Documentation for Oceanostics.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Oceanostics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../generated/two_dimensional_turbulence/">Two-dimensional turbulence</a></li><li><a class="tocitem" href="../generated/kelvin_helmholtz/">Kelvin-Helmholtz instability</a></li><li><a class="tocitem" href="../generated/tilted_bottom_boundary_layer/">Tilted bottom boundary layer</a></li></ul></li><li class="is-active"><a class="tocitem" href>Function library</a><ul class="internal"><li><a class="tocitem" href="#Oceanostics.jl"><span>Oceanostics.jl</span></a></li><li><a class="tocitem" href="#Oceanostics.TKEBudgetTerms"><span>Oceanostics.TKEBudgetTerms</span></a></li><li><a class="tocitem" href="#Oceanostics.TracerBudgetTerms"><span>Oceanostics.TracerBudgetTerms</span></a></li><li><a class="tocitem" href="#Oceanostics.TracerVarianceBudgetTerms"><span>Oceanostics.TracerVarianceBudgetTerms</span></a></li><li><a class="tocitem" href="#Oceanostics.FlowDiagnostics"><span>Oceanostics.FlowDiagnostics</span></a></li><li><a class="tocitem" href="#Oceanostics.PotentialEnergyEquationTerms"><span>Oceanostics.PotentialEnergyEquationTerms</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/tomchor/Oceanostics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/tomchor/Oceanostics.jl/blob/main/docs/src/library.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><p>Documentation for the public user interface.</p><h2 id="Oceanostics.jl"><a class="docs-heading-anchor" href="#Oceanostics.jl">Oceanostics.jl</a><a id="Oceanostics.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Oceanostics.jl" title="Permalink"></a></h2><h2 id="Oceanostics.TKEBudgetTerms"><a class="docs-heading-anchor" href="#Oceanostics.TKEBudgetTerms">Oceanostics.TKEBudgetTerms</a><a id="Oceanostics.TKEBudgetTerms-1"></a><a class="docs-heading-anchor-permalink" href="#Oceanostics.TKEBudgetTerms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.AdvectionTerm-Tuple{NonhydrostaticModel}" href="#Oceanostics.TKEBudgetTerms.AdvectionTerm-Tuple{NonhydrostaticModel}"><code>Oceanostics.TKEBudgetTerms.AdvectionTerm</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdvectionTerm(model; velocities, location)
</code></pre><p>Return a <code>KernelFunctionOperation</code> that computes the advection term, defined as</p><pre><code class="nohighlight hljs">ADV = u·µ¢‚àÇ‚±º(u·µ¢u‚±º)</code></pre><p>By default, the buoyancy production will be calculated using the resolved <code>velocities</code> and users cab use the keyword <code>velocities</code> to modify that behavior:</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size = (1, 1, 4), extent = (1,1,1));

julia&gt; model = NonhydrostaticModel(grid=grid);

julia&gt; using Oceanostics.TKEBudgetTerms: BuoyancyProductionTerm

julia&gt; using Oceanostics.TKEBudgetTerms: AdvectionTerm

julia&gt; ADV = AdvectionTerm(model)
KernelFunctionOperation at (Center, Center, Center)
‚îú‚îÄ‚îÄ grid: 1√ó1√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó3 halo
‚îú‚îÄ‚îÄ kernel_function: u·µ¢‚àÇ‚±ºu‚±ºu·µ¢·∂ú·∂ú·∂ú (generic function with 1 method)
‚îî‚îÄ‚îÄ arguments: (&quot;NamedTuple&quot;, &quot;Centered&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TKEBudgetTerms.jl#L162-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.BuoyancyProductionTerm-Tuple{NonhydrostaticModel}" href="#Oceanostics.TKEBudgetTerms.BuoyancyProductionTerm-Tuple{NonhydrostaticModel}"><code>Oceanostics.TKEBudgetTerms.BuoyancyProductionTerm</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BuoyancyProductionTerm(model; velocities, tracers, location)
</code></pre><p>Return a <code>KernelFunctionOperation</code> that computes the buoyancy production term, defined as</p><pre><code class="nohighlight hljs">BP = u·µ¢b·µ¢</code></pre><p>where b·µ¢ is the component of the buoyancy acceleration in the <code>i</code>-th direction (which is zero for x and y, except when <code>gravity_unit_vector</code> isn&#39;t aligned with the grid&#39;s z-direction) and all three components of <code>i=1,2,3</code> are added up.</p><p>By default, the buoyancy production will be calculated using the resolved <code>velocities</code> and <code>tracers</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size = (1, 1, 4), extent = (1,1,1));

julia&gt; model = NonhydrostaticModel(grid=grid, buoyancy=BuoyancyTracer(), tracers=:b);

julia&gt; using Oceanostics.TKEBudgetTerms: BuoyancyProductionTerm

julia&gt; wb = BuoyancyProductionTerm(model)
KernelFunctionOperation at (Center, Center, Center)
‚îú‚îÄ‚îÄ grid: 1√ó1√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó3 halo
‚îú‚îÄ‚îÄ kernel_function: u·µ¢b·µ¢·∂ú·∂ú·∂ú (generic function with 1 method)
‚îî‚îÄ‚îÄ arguments: (&quot;NamedTuple&quot;, &quot;BuoyancyForce&quot;, &quot;NamedTuple&quot;)</code></pre><p>If we want to calculate only the <em>turbulent</em> buoyancy production rate, we can do so by passing turbulent perturbations to the <code>velocities</code> and/or <code>tracers</code> options):</p><pre><code class="language-julia-repl hljs">julia&gt; w‚Ä≤ = Field(model.velocities.w - Field(Average(model.velocities.w)));

julia&gt; b‚Ä≤ = Field(model.tracers.b - Field(Average(model.tracers.b)));

julia&gt; w‚Ä≤b‚Ä≤ = BuoyancyProductionTerm(model, velocities=(u=model.velocities.u, v=model.velocities.v, w=w‚Ä≤), tracers=(b=b‚Ä≤,))
KernelFunctionOperation at (Center, Center, Center)
‚îú‚îÄ‚îÄ grid: 1√ó1√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó3 halo
‚îú‚îÄ‚îÄ kernel_function: u·µ¢b·µ¢·∂ú·∂ú·∂ú (generic function with 1 method)
‚îî‚îÄ‚îÄ arguments: (&quot;NamedTuple&quot;, &quot;BuoyancyForce&quot;, &quot;NamedTuple&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TKEBudgetTerms.jl#L429-L473">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.IsotropicKineticEnergyDissipationRate-Tuple{Any}" href="#Oceanostics.TKEBudgetTerms.IsotropicKineticEnergyDissipationRate-Tuple{Any}"><code>Oceanostics.TKEBudgetTerms.IsotropicKineticEnergyDissipationRate</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IsotropicKineticEnergyDissipationRate(
    model;
    U,
    V,
    W,
    location
)
</code></pre><p>Calculate the Viscous Dissipation Rate, defined as</p><pre><code class="nohighlight hljs">Œµ = 2 ŒΩ S·µ¢‚±ºS·µ¢‚±º,</code></pre><p>where S·µ¢‚±º is the strain rate tensor, for a fluid with an isotropic turbulence closure (i.e., a turbulence closure where ŒΩ (eddy or not) is the same for all directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TKEBudgetTerms.jl#L212-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.KineticEnergy-NTuple{4, Any}" href="#Oceanostics.TKEBudgetTerms.KineticEnergy-NTuple{4, Any}"><code>Oceanostics.TKEBudgetTerms.KineticEnergy</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KineticEnergy(model, u, v, w; location, kwargs...)
</code></pre><p>Calculate the kinetic energy of <code>model</code> manually specifying <code>u</code>, <code>v</code> and <code>w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TKEBudgetTerms.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.KineticEnergy-Tuple{Any}" href="#Oceanostics.TKEBudgetTerms.KineticEnergy-Tuple{Any}"><code>Oceanostics.TKEBudgetTerms.KineticEnergy</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KineticEnergy(model; kwargs...)
</code></pre><p>Calculate the kinetic energy of <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TKEBudgetTerms.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.KineticEnergyDissipationRate-Tuple{Any}" href="#Oceanostics.TKEBudgetTerms.KineticEnergyDissipationRate-Tuple{Any}"><code>Oceanostics.TKEBudgetTerms.KineticEnergyDissipationRate</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KineticEnergyDissipationRate(model; U, V, W, location)
</code></pre><p>Calculate the Kinetic Energy Dissipation Rate, defined as</p><pre><code class="nohighlight hljs">Œµ = ŒΩ (‚àÇu·µ¢/‚àÇx‚±º) (‚àÇu·µ¢/‚àÇx‚±º)
Œµ = ‚àÇ‚±ºu·µ¢ ‚ãÖ F·µ¢‚±º</code></pre><p>where ‚àÇ‚±ºu·µ¢ is the velocity gradient tensor and F·µ¢‚±º is the stress tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TKEBudgetTerms.jl#L267-L276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.KineticEnergyForcingTerm-Tuple{NonhydrostaticModel}" href="#Oceanostics.TKEBudgetTerms.KineticEnergyForcingTerm-Tuple{NonhydrostaticModel}"><code>Oceanostics.TKEBudgetTerms.KineticEnergyForcingTerm</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KineticEnergyForcingTerm(model; location)
</code></pre><p>Return a <code>KernelFunctionOperation</code> that computes the forcing term of the KE prognostic equation:</p><pre><code class="nohighlight hljs">    FORC = u·µ¢F·µ§·µ¢</code></pre><p>where <code>u·µ¢</code> are the velocity components and <code>F·µ§·µ¢</code> is the forcing term(s) in the <code>u·µ¢</code> prognostic equation (i.e. the forcing for <code>u·µ¢</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TKEBudgetTerms.jl#L345-L356">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.KineticEnergyStressTerm-Tuple{Any}" href="#Oceanostics.TKEBudgetTerms.KineticEnergyStressTerm-Tuple{Any}"><code>Oceanostics.TKEBudgetTerms.KineticEnergyStressTerm</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KineticEnergyStressTerm(model; location)
</code></pre><p>Return a <code>KernelFunctionOperation</code> that computes the diffusive term of the KE prognostic equation:</p><pre><code class="nohighlight hljs">    DIFF = u·µ¢‚àÇ‚±ºœÑ·µ¢‚±º</code></pre><p>where <code>u·µ¢</code> are the velocity components and <code>œÑ·µ¢‚±º</code> is the diffusive flux of <code>i</code> momentum in the <code>j</code>-th direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TKEBudgetTerms.jl#L305-L316">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.KineticEnergyTendency-Tuple{NonhydrostaticModel}" href="#Oceanostics.TKEBudgetTerms.KineticEnergyTendency-Tuple{NonhydrostaticModel}"><code>Oceanostics.TKEBudgetTerms.KineticEnergyTendency</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KineticEnergyTendency(model; location)
</code></pre><p>Return a <code>KernelFunctionOperation</code> that computes the tendency u·µ¢G·µ¢ of the KE, excluding the nonhydrostatic pressure contribution:</p><pre><code class="nohighlight hljs">KET = ¬Ω‚àÇ‚Çúu·µ¢¬≤ = u·µ¢G·µ¢ - u·µ¢‚àÇ·µ¢p‚Çô‚Çï‚Çõ</code></pre><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size = (1, 1, 4), extent = (1, 1, 1));

julia&gt; model = NonhydrostaticModel(; grid);

julia&gt; using Oceanostics.TKEBudgetTerms: KineticEnergyTendency

julia&gt; ke_tendency = KineticEnergyTendency(model)
KernelFunctionOperation at (Center, Center, Center)
‚îú‚îÄ‚îÄ grid: 1√ó1√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó3 halo
‚îú‚îÄ‚îÄ kernel_function: u·µ¢G·µ¢·∂ú·∂ú·∂ú (generic function with 1 method)
‚îî‚îÄ‚îÄ arguments: (&quot;Centered&quot;, &quot;Nothing&quot;, &quot;Nothing&quot;, &quot;Nothing&quot;, &quot;BoundaryCondition&quot;, &quot;BoundaryCondition&quot;, &quot;BoundaryCondition&quot;, &quot;Nothing&quot;, &quot;Oceananigans.Models.NonhydrostaticModels.BackgroundFields&quot;, &quot;NamedTuple&quot;, &quot;NamedTuple&quot;, &quot;NamedTuple&quot;, &quot;Nothing&quot;, &quot;Nothing&quot;, &quot;Clock&quot;, &quot;NamedTuple&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TKEBudgetTerms.jl#L108-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.PressureRedistributionTerm-Tuple{NonhydrostaticModel}" href="#Oceanostics.TKEBudgetTerms.PressureRedistributionTerm-Tuple{NonhydrostaticModel}"><code>Oceanostics.TKEBudgetTerms.PressureRedistributionTerm</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PressureRedistributionTerm(
    model;
    velocities,
    pressure,
    location
)
</code></pre><p>Return a <code>KernelFunctionOperation</code> that computes the pressure redistribution term:</p><pre><code class="nohighlight hljs">PR = u·µ¢‚àÇ·µ¢p</code></pre><p>where <code>p</code> is the pressure. By default <code>p</code> is taken to be the total pressure (nonhydrostatic + hydrostatic):</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size = (1, 1, 4), extent = (1,1,1));

julia&gt; model = NonhydrostaticModel(grid=grid);

julia&gt; using Oceanostics.TKEBudgetTerms: PressureRedistributionTerm

julia&gt; ‚àáu‚Éóp = PressureRedistributionTerm(model)
KernelFunctionOperation at (Center, Center, Center)
‚îú‚îÄ‚îÄ grid: 1√ó1√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó3 halo
‚îú‚îÄ‚îÄ kernel_function: u·µ¢‚àÇ·µ¢p·∂ú·∂ú·∂ú (generic function with 1 method)
‚îî‚îÄ‚îÄ arguments: (&quot;NamedTuple&quot;, &quot;Field&quot;)</code></pre><p>We can also pass <code>velocities</code> and <code>pressure</code> keywords to perform more specific calculations. The example below illustrates calculation of the nonhydrostatic contribution to the pressure redistrubution term:</p><pre><code class="language-julia-repl hljs">julia&gt; ‚àáu‚ÉópNHS = PressureRedistributionTerm(model, pressure=model.pressures.pNHS)
KernelFunctionOperation at (Center, Center, Center)
‚îú‚îÄ‚îÄ grid: 1√ó1√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó3 halo
‚îú‚îÄ‚îÄ kernel_function: u·µ¢‚àÇ·µ¢p·∂ú·∂ú·∂ú (generic function with 1 method)
‚îî‚îÄ‚îÄ arguments: (&quot;NamedTuple&quot;, &quot;Field&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TKEBudgetTerms.jl#L376-L412">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.TurbulentKineticEnergy-NTuple{4, Any}" href="#Oceanostics.TKEBudgetTerms.TurbulentKineticEnergy-NTuple{4, Any}"><code>Oceanostics.TKEBudgetTerms.TurbulentKineticEnergy</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TurbulentKineticEnergy(model, u, v, w; U, V, W, location)
</code></pre><p>Calculate the turbulent kinetic energy of <code>model</code> manually specifying <code>u</code>, <code>v</code>, <code>w</code> and optionally background velocities <code>U</code>, <code>V</code> and <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TKEBudgetTerms.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.TurbulentKineticEnergy-Tuple{Any}" href="#Oceanostics.TKEBudgetTerms.TurbulentKineticEnergy-Tuple{Any}"><code>Oceanostics.TKEBudgetTerms.TurbulentKineticEnergy</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TurbulentKineticEnergy(model; kwargs...)
</code></pre><p>Calculate the turbulent kinetic energy of <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TKEBudgetTerms.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.XShearProductionRate-NTuple{7, Any}" href="#Oceanostics.TKEBudgetTerms.XShearProductionRate-NTuple{7, Any}"><code>Oceanostics.TKEBudgetTerms.XShearProductionRate</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">XShearProductionRate(model, u, v, w, U, V, W; location)
</code></pre><p>Calculate the shear production rate in the <code>model</code>&#39;s <code>x</code> direction, considering velocities <code>u</code>, <code>v</code>, <code>w</code> and background (or average) velocities <code>U</code>, <code>V</code> and <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TKEBudgetTerms.jl#L499-L504">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.XShearProductionRate-Tuple{Any}" href="#Oceanostics.TKEBudgetTerms.XShearProductionRate-Tuple{Any}"><code>Oceanostics.TKEBudgetTerms.XShearProductionRate</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">XShearProductionRate(model; U, V, W, kwargs...)
</code></pre><p>Calculate the shear production rate in the <code>model</code>&#39;s <code>x</code> direction. At least one of the mean velocities <code>U</code>, <code>V</code> and <code>W</code> must be specified otherwise the output will be zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TKEBudgetTerms.jl#L511-L516">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.YShearProductionRate-NTuple{7, Any}" href="#Oceanostics.TKEBudgetTerms.YShearProductionRate-NTuple{7, Any}"><code>Oceanostics.TKEBudgetTerms.YShearProductionRate</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">YShearProductionRate(model, u, v, w, U, V, W; location)
</code></pre><p>Calculate the shear production rate in the <code>model</code>&#39;s <code>y</code> direction, considering velocities <code>u</code>, <code>v</code>, <code>w</code> and background (or average) velocities <code>U</code>, <code>V</code> and <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TKEBudgetTerms.jl#L541-L546">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.YShearProductionRate-Tuple{Any}" href="#Oceanostics.TKEBudgetTerms.YShearProductionRate-Tuple{Any}"><code>Oceanostics.TKEBudgetTerms.YShearProductionRate</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">YShearProductionRate(model; U, V, W, kwargs...)
</code></pre><p>Calculate the shear production rate in the <code>model</code>&#39;s <code>y</code> direction. At least one of the mean velocities <code>U</code>, <code>V</code> and <code>W</code> must be specified otherwise the output will be zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TKEBudgetTerms.jl#L553-L558">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.ZShearProductionRate-NTuple{7, Any}" href="#Oceanostics.TKEBudgetTerms.ZShearProductionRate-NTuple{7, Any}"><code>Oceanostics.TKEBudgetTerms.ZShearProductionRate</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ZShearProductionRate(model, u, v, w, U, V, W; location)
</code></pre><p>Calculate the shear production rate in the <code>model</code>&#39;s <code>z</code> direction, considering velocities <code>u</code>, <code>v</code>, <code>w</code> and background (or average) velocities <code>U</code>, <code>V</code> and <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TKEBudgetTerms.jl#L583-L588">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.ZShearProductionRate-Tuple{Any}" href="#Oceanostics.TKEBudgetTerms.ZShearProductionRate-Tuple{Any}"><code>Oceanostics.TKEBudgetTerms.ZShearProductionRate</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ZShearProductionRate(model; U, V, W, kwargs...)
</code></pre><p>Calculate the shear production rate in the <code>model</code>&#39;s <code>z</code> direction. At least one of the mean velocities <code>U</code>, <code>V</code> and <code>W</code> must be specified otherwise the output will be zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TKEBudgetTerms.jl#L595-L600">source</a></section></article><h2 id="Oceanostics.TracerBudgetTerms"><a class="docs-heading-anchor" href="#Oceanostics.TracerBudgetTerms">Oceanostics.TracerBudgetTerms</a><a id="Oceanostics.TracerBudgetTerms-1"></a><a class="docs-heading-anchor-permalink" href="#Oceanostics.TracerBudgetTerms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TracerBudgetTerms.ImmersedTracerDiffusion-NTuple{8, Any}" href="#Oceanostics.TracerBudgetTerms.ImmersedTracerDiffusion-NTuple{8, Any}"><code>Oceanostics.TracerBudgetTerms.ImmersedTracerDiffusion</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ImmersedTracerDiffusion(
    model,
    c,
    c_immersed_bc,
    closure,
    diffusivity_fields,
    val_tracer_index,
    clock,
    model_fields;
    location
)
</code></pre><p>Calculates the diffusion term due to the bathymetry term as</p><pre><code class="nohighlight hljs">DIFF = ‚àÇ‚±º ùìÜ·∂ú‚±º,</code></pre><p>where ùìÜ·∂ú‚±º is the bathymetry-led diffusion tensor for tracer <code>c</code>, using the Oceananigans&#39; kernel <code>immersed_‚àá_dot_q·∂ú</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceanostics

julia&gt; grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));

julia&gt; model = NonhydrostaticModel(; grid, tracers=:a);

julia&gt; DIFF = ImmersedTracerDiffusion(model, :a)
KernelFunctionOperation at (Center, Center, Center)
‚îú‚îÄ‚îÄ grid: 4√ó4√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo
‚îú‚îÄ‚îÄ kernel_function: immersed_‚àá_dot_q·∂ú (generic function with 2 methods)
‚îî‚îÄ‚îÄ arguments: (&quot;Field&quot;, &quot;BoundaryCondition&quot;, &quot;Nothing&quot;, &quot;Nothing&quot;, &quot;Val&quot;, &quot;Clock&quot;, &quot;NamedTuple&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TracerBudgetTerms.jl#L89-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TracerBudgetTerms.TotalTracerDiffusion-NTuple{9, Any}" href="#Oceanostics.TracerBudgetTerms.TotalTracerDiffusion-NTuple{9, Any}"><code>Oceanostics.TracerBudgetTerms.TotalTracerDiffusion</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TotalTracerDiffusion(
    model,
    c,
    c_immersed_bc,
    closure,
    diffusivity_fields,
    val_tracer_index,
    clock,
    model_fields,
    buoyancy;
    location
)
</code></pre><p>Calculates the total diffusion term as</p><pre><code class="nohighlight hljs">DIFF = ‚àÇ‚±º q·∂ú‚±º + ‚àÇ‚±º ùìÜ·∂ú‚±º,</code></pre><p><code>c</code>. The calculation is done using the Oceananigans&#39; kernels <code>‚àá_dot_q·∂ú</code> and <code>immersed_‚àá_dot_q·∂ú</code>. where q·∂ú‚±º is the interior diffusion tensor and ùìÜ·∂ú‚±º is the bathymetry-led diffusion tensor for tracer</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceanostics

julia&gt; grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));

julia&gt; model = NonhydrostaticModel(; grid, tracers=:a);

julia&gt; DIFF = TotalTracerDiffusion(model, :a)
KernelFunctionOperation at (Center, Center, Center)
‚îú‚îÄ‚îÄ grid: 4√ó4√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo
‚îú‚îÄ‚îÄ kernel_function: total_‚àá_dot_q·∂ú (generic function with 1 method)
‚îî‚îÄ‚îÄ arguments: (&quot;Field&quot;, &quot;BoundaryCondition&quot;, &quot;Nothing&quot;, &quot;Nothing&quot;, &quot;Val&quot;, &quot;Clock&quot;, &quot;NamedTuple&quot;, &quot;Nothing&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TracerBudgetTerms.jl#L129-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TracerBudgetTerms.TracerAdvection-NTuple{6, Any}" href="#Oceanostics.TracerBudgetTerms.TracerAdvection-NTuple{6, Any}"><code>Oceanostics.TracerBudgetTerms.TracerAdvection</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TracerAdvection(model, u, v, w, c, advection; location)
</code></pre><p>Calculates the advection of the tracer <code>c</code> as</p><pre><code class="nohighlight hljs">ADV = ‚àÇ‚±º (u‚±º c)</code></pre><p>using Oceananigans&#39; kernel <a href="https://clima.github.io/OceananigansDocumentation/stable/appendix/library/#Oceananigans.Advection.div_Uc-NTuple{7,%20Any}"><code>div_Uc</code>.</a></p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceanostics

julia&gt; grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));

julia&gt; model = NonhydrostaticModel(; grid, tracers=:a);

julia&gt; ADV = TracerAdvection(model, :a)
KernelFunctionOperation at (Center, Center, Center)
‚îú‚îÄ‚îÄ grid: 4√ó4√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo
‚îú‚îÄ‚îÄ kernel_function: div_Uc (generic function with 10 methods)
‚îî‚îÄ‚îÄ arguments: (&quot;Centered&quot;, &quot;NamedTuple&quot;, &quot;Field&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TracerBudgetTerms.jl#L13-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TracerBudgetTerms.TracerDiffusion-NTuple{8, Any}" href="#Oceanostics.TracerBudgetTerms.TracerDiffusion-NTuple{8, Any}"><code>Oceanostics.TracerBudgetTerms.TracerDiffusion</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TracerDiffusion(
    model,
    val_tracer_index,
    c,
    closure,
    diffusivity_fields,
    clock,
    model_fields,
    buoyancy;
    location
)
</code></pre><p>Calculates the diffusion term (excluding anything due to the bathymetry) as</p><pre><code class="nohighlight hljs">DIFF = ‚àÇ‚±º q·∂ú‚±º,</code></pre><p>where q·∂ú‚±º is the diffusion tensor for tracer <code>c</code>, using the Oceananigans&#39; kernel <code>‚àá_dot_q·∂ú</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceanostics

julia&gt; grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));

julia&gt; model = NonhydrostaticModel(; grid, tracers=:a);

julia&gt; DIFF = TracerDiffusion(model, :a)
KernelFunctionOperation at (Center, Center, Center)
‚îú‚îÄ‚îÄ grid: 4√ó4√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo
‚îú‚îÄ‚îÄ kernel_function: ‚àá_dot_q·∂ú (generic function with 10 methods)
‚îî‚îÄ‚îÄ arguments: (&quot;Nothing&quot;, &quot;Nothing&quot;, &quot;Val&quot;, &quot;Field&quot;, &quot;Clock&quot;, &quot;NamedTuple&quot;, &quot;Nothing&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TracerBudgetTerms.jl#L54-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TracerBudgetTerms.TracerForcing-NTuple{4, Any}" href="#Oceanostics.TracerBudgetTerms.TracerForcing-NTuple{4, Any}"><code>Oceanostics.TracerBudgetTerms.TracerForcing</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TracerForcing(model, forcing, clock, model_fields; location)
</code></pre><p>Calculate the forcing term <code>F·∂ú</code> on the equation for tracer <code>c</code> for <code>model</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, Oceanostics

julia&gt; grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));

julia&gt; model = NonhydrostaticModel(; grid, tracers=:a);

julia&gt; FORC = TracerForcing(model, :a)
KernelFunctionOperation at (Center, Center, Center)
‚îú‚îÄ‚îÄ grid: 4√ó4√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo
‚îú‚îÄ‚îÄ kernel_function: zeroforcing (generic function with 1 method)
‚îî‚îÄ‚îÄ arguments: (&quot;Clock&quot;, &quot;NamedTuple&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TracerBudgetTerms.jl#L167-L185">source</a></section></article><h2 id="Oceanostics.TracerVarianceBudgetTerms"><a class="docs-heading-anchor" href="#Oceanostics.TracerVarianceBudgetTerms">Oceanostics.TracerVarianceBudgetTerms</a><a id="Oceanostics.TracerVarianceBudgetTerms-1"></a><a class="docs-heading-anchor-permalink" href="#Oceanostics.TracerVarianceBudgetTerms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TracerVarianceBudgetTerms.TracerVarianceDiffusiveTerm-Tuple{Any, Any}" href="#Oceanostics.TracerVarianceBudgetTerms.TracerVarianceDiffusiveTerm-Tuple{Any, Any}"><code>Oceanostics.TracerVarianceBudgetTerms.TracerVarianceDiffusiveTerm</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TracerVarianceDiffusiveTerm(model, tracer_name; location)
</code></pre><p>Return a <code>KernelFunctionOperation</code> that computes the diffusive term of the tracer variance prognostic equation using Oceananigans&#39; diffusive tracer flux divergence kernel:</p><pre><code class="nohighlight hljs">    DIFF = 2 c ‚àÇ‚±ºF‚±º</code></pre><p>where <code>c</code> is the tracer, and <code>F‚±º</code> is the tracer&#39;s diffusive flux in the <code>j</code>-th direction.</p><pre><code class="language-julia hljs">grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1))
model = NonhydrostaticModel(grid=grid, tracers=:b, closure=SmagorinskyLilly())

DIFF = TracerVarianceDiffusiveTerm(model, :b)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TracerVarianceBudgetTerms.jl#L96-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TracerVarianceBudgetTerms.TracerVarianceDissipationRate-Tuple{Any, Any}" href="#Oceanostics.TracerVarianceBudgetTerms.TracerVarianceDissipationRate-Tuple{Any, Any}"><code>Oceanostics.TracerVarianceBudgetTerms.TracerVarianceDissipationRate</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TracerVarianceDissipationRate(
    model,
    tracer_name;
    tracer,
    location
)
</code></pre><p>Return a <code>KernelFunctionOperation</code> that computes the isotropic variance dissipation rate for <code>tracer_name</code> in <code>model.tracers</code>. The isotropic variance dissipation rate is defined as</p><pre><code class="nohighlight hljs">    œá = 2 ‚àÇ‚±ºc ‚ãÖ F‚±º</code></pre><p>where <code>F‚±º</code> is the diffusive flux of <code>c</code> in the <code>j</code>-th direction and <code>‚àÇ‚±º</code> is the gradient operator. <code>œá</code> is implemented in its conservative formulation based on the equation above.</p><p>Note that often <code>œá</code> is written as <code>œá = 2Œ∫ (‚àác ‚ãÖ ‚àác)</code>, which is the special case for Fickian diffusion (<code>Œ∫</code> is the tracer diffusivity).</p><p>Here <code>tracer_name</code> is needed even when passing <code>tracer</code> in order to get the appropriate <code>tracer_index</code>. When passing <code>tracer</code>, this function should be used as</p><pre><code class="language-julia hljs">grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1))
model = NonhydrostaticModel(grid=grid, tracers=:b, closure=SmagorinskyLilly())

bÃÑ = Field(Average(model.tracers.b, dims=(1,2)))
b‚Ä≤ = model.tracers.b - bÃÑ

œáb = TracerVarianceDissipationRate(model, :b, tracer=b‚Ä≤)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TracerVarianceBudgetTerms.jl#L148-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TracerVarianceBudgetTerms.TracerVarianceTendency-Tuple{NonhydrostaticModel, Any}" href="#Oceanostics.TracerVarianceBudgetTerms.TracerVarianceTendency-Tuple{NonhydrostaticModel, Any}"><code>Oceanostics.TracerVarianceBudgetTerms.TracerVarianceTendency</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TracerVarianceTendency(model, tracer_name; location)
</code></pre><p>Return a <code>KernelFunctionOperation</code> that computes the tracer variance tendency:</p><pre><code class="nohighlight hljs">TEND = 2 c ‚àÇ‚Çúc</code></pre><p>where <code>c</code> is the tracer and <code>‚àÇ‚Çúc</code> is the tracer tendency (computed using Oceananigans&#39; tracer tendency kernel).</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size = (1, 1, 4), extent = (1, 1, 1));

julia&gt; model = NonhydrostaticModel(; grid, tracers=:b);

julia&gt; using Oceanostics.TracerVarianceBudgetTerms: TracerVarianceTendency

julia&gt; œá = TracerVarianceTendency(model, :b)
KernelFunctionOperation at (Center, Center, Center)
‚îú‚îÄ‚îÄ grid: 1√ó1√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó3 halo
‚îú‚îÄ‚îÄ kernel_function: c‚àÇ‚Çúc·∂ú·∂ú·∂ú (generic function with 1 method)
‚îî‚îÄ‚îÄ arguments: (&quot;Val&quot;, &quot;Val&quot;, &quot;Centered&quot;, &quot;Nothing&quot;, &quot;BoundaryCondition&quot;, &quot;Nothing&quot;, &quot;Nothing&quot;, &quot;Oceananigans.Models.NonhydrostaticModels.BackgroundFields&quot;, &quot;NamedTuple&quot;, &quot;NamedTuple&quot;, &quot;NamedTuple&quot;, &quot;Nothing&quot;, &quot;Clock&quot;, &quot;typeof(Oceananigans.Forcings.zeroforcing)&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/TracerVarianceBudgetTerms.jl#L39-L64">source</a></section></article><h2 id="Oceanostics.FlowDiagnostics"><a class="docs-heading-anchor" href="#Oceanostics.FlowDiagnostics">Oceanostics.FlowDiagnostics</a><a id="Oceanostics.FlowDiagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Oceanostics.FlowDiagnostics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.BuoyancyAnomalyCriterion" href="#Oceanostics.FlowDiagnostics.BuoyancyAnomalyCriterion"><code>Oceanostics.FlowDiagnostics.BuoyancyAnomalyCriterion</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct BuoyancyAnomalyCriterion{FT} &lt;: Oceanostics.FlowDiagnostics.AbstractAnomalyCriterion</code></pre><p>Defines the mixed layer to be the depth at which the buoyancy is more than <code>threshold</code> greater than the surface buoyancy (but the pertubaton is usually negative).</p><p>When this model is used, the arguments <code>buoyancy_formulation</code> and <code>C</code> should be supplied where <code>C</code> should be the named tuple <code>(; b)</code>, with <code>b</code> the buoyancy tracer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/FlowDiagnostics.jl#L524-L532">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.DensityAnomalyCriterion" href="#Oceanostics.FlowDiagnostics.DensityAnomalyCriterion"><code>Oceanostics.FlowDiagnostics.DensityAnomalyCriterion</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DensityAnomalyCriterion{FT} &lt;: Oceanostics.FlowDiagnostics.AbstractAnomalyCriterion</code></pre><p>Defines the mixed layer to be the depth at which the density is more than <code>threshold</code> greater than the surface density.</p><p>When this model is used, the arguments <code>buoyancy_formulation</code> and <code>C</code> should be supplied where <code>buoyancy_formulation</code> should be the buoyancy model, and <code>C</code> should be a named tuple of <code>(; T, S)</code>, <code>(; T)</code> or <code>(; S)</code> (the latter two if the buoyancy model specifies a constant salinity or temperature).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/FlowDiagnostics.jl#L544-L554">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.BottomCellValue-Tuple{Any}" href="#Oceanostics.FlowDiagnostics.BottomCellValue-Tuple{Any}"><code>Oceanostics.FlowDiagnostics.BottomCellValue</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BottomCellValue(diagnostic)
</code></pre><p>Returns the value of the given <code>diagnostic</code> at the bottom, which can be either the bottom of the domain (lowest vertical level) or an immersed bottom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/FlowDiagnostics.jl#L583-L588">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.DirectionalErtelPotentialVorticity-Tuple{Any, Any}" href="#Oceanostics.FlowDiagnostics.DirectionalErtelPotentialVorticity-Tuple{Any, Any}"><code>Oceanostics.FlowDiagnostics.DirectionalErtelPotentialVorticity</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DirectionalErtelPotentialVorticity(
    model,
    direction;
    tracer_name,
    loc
)
</code></pre><p>Calculate the contribution from a given <code>direction</code> to the Ertel Potential Vorticity basde on a <code>model</code> and a <code>direction</code>. The Ertel Potential Vorticity is defined as</p><pre><code class="nohighlight hljs">EPV = œâ‚Çú‚Çí‚Çú ‚ãÖ ‚àáb</code></pre><p>where œâ‚Çú‚Çí‚Çú is the total (relative + planetary) vorticity vector, <code>b</code> is the buoyancy and ‚àá is the gradient operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/FlowDiagnostics.jl#L317-L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.ErtelPotentialVorticity-Tuple{Any}" href="#Oceanostics.FlowDiagnostics.ErtelPotentialVorticity-Tuple{Any}"><code>Oceanostics.FlowDiagnostics.ErtelPotentialVorticity</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ErtelPotentialVorticity(model; tracer_name, loc)
</code></pre><p>Calculate the Ertel Potential Vorticty for <code>model</code>, where the characteristics of the Coriolis rotation are taken from <code>model.coriolis</code>. The Ertel Potential Vorticity is defined as</p><pre><code class="nohighlight hljs">EPV = œâ‚Çú‚Çí‚Çú ‚ãÖ ‚àáb</code></pre><p>where œâ‚Çú‚Çí‚Çú is the total (relative + planetary) vorticity vector, <code>b</code> is the buoyancy and ‚àá is the gradient operator.</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(topology = (Flat, Flat, Bounded), size = 4, extent = 1);

julia&gt; N¬≤ = 1e-6;

julia&gt; b_bcs = FieldBoundaryConditions(top=GradientBoundaryCondition(N¬≤));

julia&gt; model = NonhydrostaticModel(; grid, coriolis=FPlane(1e-4), buoyancy=BuoyancyTracer(), tracers=:b, boundary_conditions=(; b=b_bcs));

julia&gt; stratification(z) = N¬≤ * z;

julia&gt; set!(model, b=stratification)

julia&gt; using Oceanostics: ErtelPotentialVorticity

julia&gt; EPV = ErtelPotentialVorticity(model)
KernelFunctionOperation at (Face, Face, Face)
‚îú‚îÄ‚îÄ grid: 1√ó1√ó4 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0√ó0√ó3 halo
‚îú‚îÄ‚îÄ kernel_function: ertel_potential_vorticity_fff (generic function with 1 method)
‚îî‚îÄ‚îÄ arguments: (&quot;Field&quot;, &quot;Field&quot;, &quot;Field&quot;, &quot;Field&quot;, &quot;Int64&quot;, &quot;Int64&quot;, &quot;Float64&quot;)

julia&gt; interior(compute!(Field(EPV)))
1√ó1√ó5 view(::Array{Float64, 3}, 1:1, 1:1, 4:8) with eltype Float64:
[:, :, 1] =
 0.0

[:, :, 2] =
 1.0000000000000002e-10

[:, :, 3] =
 9.999999999999998e-11

[:, :, 4] =
 1.0000000000000002e-10

[:, :, 5] =
 1.0e-10</code></pre><p>Note that EPV values are correctly calculated both in the interior and the boundaries. In the interior and top boundary, EPV = f√óN¬≤ = 10‚Åª¬π‚Å∞, while EPV = 0 at the bottom boundary since ‚àÇb/‚àÇz is zero there.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/FlowDiagnostics.jl#L223-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.MixedLayerDepth-Tuple{Oceananigans.Grids.AbstractGrid, Vararg{Any}}" href="#Oceanostics.FlowDiagnostics.MixedLayerDepth-Tuple{Oceananigans.Grids.AbstractGrid, Vararg{Any}}"><code>Oceanostics.FlowDiagnostics.MixedLayerDepth</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MixedLayerDepth(grid, args; criterion)
</code></pre><p>Returns the mixed layer depth defined as the depth at which <code>criterion</code> is true.</p><p>Defaults to <code>DensityAnomalyCriterion</code> where the depth is that at which the density is some threshold (defaults to 0.125kg/m¬≥) higher than the surface density.</p><p>When <code>DensityAnomalyCriterion</code> is used, the arguments <code>buoyancy_formulation</code> and <code>C</code> should be supplied where <code>buoyancy_formulation</code> should be the buoyancy model, and <code>C</code> should be a named tuple of <code>(; T, S)</code>, <code>(; T)</code> or <code>(; S)</code> (the latter two if the buoyancy model specifies a constant salinity or temperature).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/FlowDiagnostics.jl#L459-L471">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.QVelocityGradientTensorInvariant-Tuple{Any}" href="#Oceanostics.FlowDiagnostics.QVelocityGradientTensorInvariant-Tuple{Any}"><code>Oceanostics.FlowDiagnostics.QVelocityGradientTensorInvariant</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QVelocityGradientTensorInvariant(model; loc)
</code></pre><p>Calculate the value of the <code>Q</code> velocity gradient tensor invariant. This is usually just called <code>Q</code> and it is generally used for identifying and visualizing vortices in fluid flow.</p><p>The definition and nomenclature comes from the equation for the eigenvalues <code>Œª</code> of the velocity gradient tensor <code>‚àÇ‚±ºu·µ¢</code>:</p><pre><code class="nohighlight hljs">    Œª¬≥ + P Œª¬≤ + Q Œª + T = 0</code></pre><p>from where <code>Q</code> is defined as</p><pre><code class="nohighlight hljs">    Q = ¬Ω (Œ©·µ¢‚±ºŒ©·µ¢‚±º - S·µ¢‚±ºS·µ¢‚±º)</code></pre><p>and where <code>S·µ¢‚±º= ¬Ω(‚àÇ‚±ºu·µ¢ + ‚àÇ·µ¢u‚±º)</code> and <code>Œ©·µ¢‚±º= ¬Ω(‚àÇ‚±ºu·µ¢ - ‚àÇ·µ¢u‚±º)</code>. More info about it can be found in doi:10.1063/1.5124245.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/FlowDiagnostics.jl#L425-L444">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.RichardsonNumber-Tuple{Any}" href="#Oceanostics.FlowDiagnostics.RichardsonNumber-Tuple{Any}"><code>Oceanostics.FlowDiagnostics.RichardsonNumber</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RichardsonNumber(model; loc)
</code></pre><p>Calculate the Richardson Number as</p><pre><code class="nohighlight hljs">    Ri = (‚àÇb/‚àÇz) / (|‚àÇu‚Éó‚Çï/‚àÇz|¬≤)</code></pre><p>where <code>z</code> is the true vertical direction (ie anti-parallel to gravity).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/FlowDiagnostics.jl#L66-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.RossbyNumber-Tuple{Any}" href="#Oceanostics.FlowDiagnostics.RossbyNumber-Tuple{Any}"><code>Oceanostics.FlowDiagnostics.RossbyNumber</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RossbyNumber(
    model;
    loc,
    add_background,
    dWdy_bg,
    dVdz_bg,
    dUdz_bg,
    dWdx_bg,
    dUdy_bg,
    dVdx_bg
)
</code></pre><p>Calculate the Rossby number using the vorticity in the rotation axis direction according to <code>model.coriolis</code>. Rossby number is defined as</p><pre><code class="nohighlight hljs">    Ro = œâ·∂ª / f</code></pre><p>where œâ·∂ª is the vorticity in the Coriolis axis of rotation and <code>f</code> is the Coriolis rotation frequency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/FlowDiagnostics.jl#L119-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.StrainRateTensorModulus-Tuple{Any}" href="#Oceanostics.FlowDiagnostics.StrainRateTensorModulus-Tuple{Any}"><code>Oceanostics.FlowDiagnostics.StrainRateTensorModulus</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StrainRateTensorModulus(model; loc)
</code></pre><p>Calculate the modulus (absolute value) of the strain rate tensor <code>S</code>, which is defined as the symmetric part of the velocity gradient tensor:</p><pre><code class="nohighlight hljs">    S·µ¢‚±º = ¬Ω(‚àÇ‚±ºu·µ¢ + ‚àÇ·µ¢u‚±º)</code></pre><p>Its modulus is then defined (using Einstein summation notation) as</p><pre><code class="nohighlight hljs">    || S·µ¢‚±º || = ‚àö(S·µ¢‚±º S·µ¢‚±º)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/FlowDiagnostics.jl#L361-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.ThermalWindPotentialVorticity-Tuple{Any}" href="#Oceanostics.FlowDiagnostics.ThermalWindPotentialVorticity-Tuple{Any}"><code>Oceanostics.FlowDiagnostics.ThermalWindPotentialVorticity</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ThermalWindPotentialVorticity(model; tracer_name, loc)
</code></pre><p>Calculate the Potential Vorticty assuming thermal wind balance for <code>model</code>, where the characteristics of the Coriolis rotation are taken from <code>model.coriolis</code>. The Potential Vorticity in this case is defined as</p><pre><code class="nohighlight hljs">    TWPV = (f + œâ·∂ª) ‚àÇb/‚àÇz - f ((‚àÇU/‚àÇz)¬≤ + (‚àÇV/‚àÇz)¬≤)</code></pre><p>where <code>f</code> is the Coriolis frequency, <code>œâ·∂ª</code> is the relative vorticity in the <code>z</code> direction, <code>b</code> is the buoyancy, and <code>‚àÇU/‚àÇz</code> and <code>‚àÇV/‚àÇz</code> comprise the thermal wind shear.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/FlowDiagnostics.jl#L178-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.VorticityTensorModulus-Tuple{Any}" href="#Oceanostics.FlowDiagnostics.VorticityTensorModulus-Tuple{Any}"><code>Oceanostics.FlowDiagnostics.VorticityTensorModulus</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VorticityTensorModulus(model; loc)
</code></pre><p>Calculate the modulus (absolute value) of the vorticity tensor <code>Œ©</code>, which is defined as the antisymmetric part of the velocity gradient tensor:</p><pre><code class="nohighlight hljs">    Œ©·µ¢‚±º = ¬Ω(‚àÇ‚±ºu·µ¢ - ‚àÇ·µ¢u‚±º)</code></pre><p>Its modulus is then defined (using Einstein summation notation) as</p><pre><code class="nohighlight hljs">    || Œ©·µ¢‚±º || = ‚àö(Œ©·µ¢‚±º Œ©·µ¢‚±º)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/FlowDiagnostics.jl#L395-L409">source</a></section></article><h2 id="Oceanostics.PotentialEnergyEquationTerms"><a class="docs-heading-anchor" href="#Oceanostics.PotentialEnergyEquationTerms">Oceanostics.PotentialEnergyEquationTerms</a><a id="Oceanostics.PotentialEnergyEquationTerms-1"></a><a class="docs-heading-anchor-permalink" href="#Oceanostics.PotentialEnergyEquationTerms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.PotentialEnergyEquationTerms.PotentialEnergy-Tuple{Any}" href="#Oceanostics.PotentialEnergyEquationTerms.PotentialEnergy-Tuple{Any}"><code>Oceanostics.PotentialEnergyEquationTerms.PotentialEnergy</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PotentialEnergy(model; location, geopotential_height)
</code></pre><p>Return a <code>KernelFunctionOperation</code> to compute the <code>PotentialEnergy</code> per unit volume,</p><p class="math-container">\[E‚Çö = \frac{gœÅ}{œÅ‚ÇÄ}z = -bz\]</p><p>at each grid <code>location</code> in <code>model</code>. <code>PotentialEnergy</code> is defined for both <code>BuoyancyTracer</code> and <code>SeawaterBuoyancy</code>. See the relevant Oceananigans.jl documentation on <a href="https://clima.github.io/OceananigansDocumentation/dev/model_setup/buoyancy_and_equation_of_state/">buoyancy models</a> for more information about available options.</p><p>The optional keyword argument <code>geopotential_height</code> is only used if ones wishes to calculate <code>E‚Çö</code> with a potential density referenced to <code>geopotential_height</code>, rather than in-situ density, when using a <code>BoussinesqEquationOfState</code>.</p><p><strong>Example</strong></p><p>Usage with a <code>BuoyancyTracer</code> buoyacny model</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; using Oceanostics.PotentialEnergyEquationTerms: PotentialEnergy

julia&gt; grid = RectilinearGrid(size=100, z=(-1000, 0), topology=(Flat, Flat, Bounded))
1√ó1√ó100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0√ó0√ó3 halo
‚îú‚îÄ‚îÄ Flat x
‚îú‚îÄ‚îÄ Flat y
‚îî‚îÄ‚îÄ Bounded  z ‚àà [-1000.0, 0.0] regularly spaced with Œîz=10.0

julia&gt; model = NonhydrostaticModel(; grid, buoyancy=BuoyancyTracer(), tracers=(:b,))
NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)
‚îú‚îÄ‚îÄ grid: 1√ó1√ó100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0√ó0√ó3 halo
‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper
‚îú‚îÄ‚îÄ advection scheme: Centered(order=2)
‚îú‚îÄ‚îÄ tracers: b
‚îú‚îÄ‚îÄ closure: Nothing
‚îú‚îÄ‚îÄ buoyancy: BuoyancyTracer with gÃÇ = NegativeZDirection()
‚îî‚îÄ‚îÄ coriolis: Nothing

julia&gt; PotentialEnergy(model)
KernelFunctionOperation at (Center, Center, Center)
‚îú‚îÄ‚îÄ grid: 1√ó1√ó100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0√ó0√ó3 halo
‚îú‚îÄ‚îÄ kernel_function: minus_bz_ccc (generic function with 3 methods)
‚îî‚îÄ‚îÄ arguments: (&quot;Field&quot;,)</code></pre><p>The default behaviour of <code>PotentialEnergy</code> uses the <em>in-situ density</em> in the calculation when the equation of state is a <code>BoussinesqEquationOfState</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, SeawaterPolynomials.TEOS10

julia&gt; using Oceanostics.PotentialEnergyEquationTerms: PotentialEnergy

julia&gt; grid = RectilinearGrid(size=100, z=(-1000, 0), topology=(Flat, Flat, Bounded))
1√ó1√ó100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0√ó0√ó3 halo
‚îú‚îÄ‚îÄ Flat x
‚îú‚îÄ‚îÄ Flat y
‚îî‚îÄ‚îÄ Bounded  z ‚àà [-1000.0, 0.0] regularly spaced with Œîz=10.0

julia&gt; tracers = (:T, :S)
(:T, :S)

julia&gt; eos = TEOS10EquationOfState()
BoussinesqEquationOfState{Float64}:
‚îú‚îÄ‚îÄ seawater_polynomial: TEOS10SeawaterPolynomial{Float64}
‚îî‚îÄ‚îÄ reference_density: 1020.0

julia&gt; buoyancy = SeawaterBuoyancy(equation_of_state=eos)
SeawaterBuoyancy{Float64}:
‚îú‚îÄ‚îÄ gravitational_acceleration: 9.80665
‚îî‚îÄ‚îÄ equation_of_state: BoussinesqEquationOfState{Float64}

julia&gt; model = NonhydrostaticModel(; grid, buoyancy, tracers)
NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)
‚îú‚îÄ‚îÄ grid: 1√ó1√ó100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0√ó0√ó3 halo
‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper
‚îú‚îÄ‚îÄ advection scheme: Centered(order=2)
‚îú‚îÄ‚îÄ tracers: (T, S)
‚îú‚îÄ‚îÄ closure: Nothing
‚îú‚îÄ‚îÄ buoyancy: SeawaterBuoyancy with g=9.80665 and BoussinesqEquationOfState{Float64} with gÃÇ = NegativeZDirection()
‚îî‚îÄ‚îÄ coriolis: Nothing

julia&gt; PotentialEnergy(model)
KernelFunctionOperation at (Center, Center, Center)
‚îú‚îÄ‚îÄ grid: 1√ó1√ó100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0√ó0√ó3 halo
‚îú‚îÄ‚îÄ kernel_function: minus_bz_ccc (generic function with 3 methods)
‚îî‚îÄ‚îÄ arguments: (&quot;KernelFunctionOperation&quot;, &quot;NamedTuple&quot;)</code></pre><p>To use a reference density set a constant value for the keyword argument <code>geopotential_height</code> and pass this the function. For example,</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, SeawaterPolynomials.TEOS10;

julia&gt; using Oceanostics.PotentialEnergyEquationTerms: PotentialEnergy;

julia&gt; grid = RectilinearGrid(size=100, z=(-1000, 0), topology=(Flat, Flat, Bounded));

julia&gt; tracers = (:T, :S);

julia&gt; eos = TEOS10EquationOfState();

julia&gt; buoyancy = SeawaterBuoyancy(equation_of_state=eos);

julia&gt; model = NonhydrostaticModel(; grid, buoyancy, tracers);

julia&gt; geopotential_height = 0; # density variable will be œÉ‚ÇÄ

julia&gt; PotentialEnergy(model)
KernelFunctionOperation at (Center, Center, Center)
‚îú‚îÄ‚îÄ grid: 1√ó1√ó100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0√ó0√ó3 halo
‚îú‚îÄ‚îÄ kernel_function: minus_bz_ccc (generic function with 3 methods)
‚îî‚îÄ‚îÄ arguments: (&quot;KernelFunctionOperation&quot;, &quot;NamedTuple&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/5512355a520fa979426180a786e656c2f8cdce87/src/PotentialEnergyEquationTerms.jl#L29-L145">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../generated/tilted_bottom_boundary_layer/">¬´ Tilted bottom boundary layer</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Tuesday 3 June 2025 15:03">Tuesday 3 June 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
