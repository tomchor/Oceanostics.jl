<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function library · Oceanostics.jl</title><meta name="title" content="Function library · Oceanostics.jl"/><meta property="og:title" content="Function library · Oceanostics.jl"/><meta property="twitter:title" content="Function library · Oceanostics.jl"/><meta name="description" content="Documentation for Oceanostics.jl."/><meta property="og:description" content="Documentation for Oceanostics.jl."/><meta property="twitter:description" content="Documentation for Oceanostics.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Oceanostics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../generated/two_dimensional_turbulence/">Two-dimensional turbulence</a></li><li><a class="tocitem" href="../generated/kelvin_helmholtz/">Kelvin-Helmholtz instability</a></li><li><a class="tocitem" href="../generated/tilted_bottom_boundary_layer/">Tilted bottom boundary layer</a></li></ul></li><li class="is-active"><a class="tocitem" href>Function library</a><ul class="internal"><li><a class="tocitem" href="#Oceanostics.jl"><span>Oceanostics.jl</span></a></li><li><a class="tocitem" href="#Oceanostics.TKEBudgetTerms"><span>Oceanostics.TKEBudgetTerms</span></a></li><li><a class="tocitem" href="#Oceanostics.TracerVarianceBudgetTerms"><span>Oceanostics.TracerVarianceBudgetTerms</span></a></li><li><a class="tocitem" href="#Oceanostics.FlowDiagnostics"><span>Oceanostics.FlowDiagnostics</span></a></li><li><a class="tocitem" href="#Oceanostics.PotentialEnergyEquationTerms"><span>Oceanostics.PotentialEnergyEquationTerms</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/tomchor/Oceanostics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/tomchor/Oceanostics.jl/blob/main/docs/src/library.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><p>Documentation for the public user interface.</p><h2 id="Oceanostics.jl"><a class="docs-heading-anchor" href="#Oceanostics.jl">Oceanostics.jl</a><a id="Oceanostics.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Oceanostics.jl" title="Permalink"></a></h2><h2 id="Oceanostics.TKEBudgetTerms"><a class="docs-heading-anchor" href="#Oceanostics.TKEBudgetTerms">Oceanostics.TKEBudgetTerms</a><a id="Oceanostics.TKEBudgetTerms-1"></a><a class="docs-heading-anchor-permalink" href="#Oceanostics.TKEBudgetTerms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.AdvectionTerm-Tuple{NonhydrostaticModel}" href="#Oceanostics.TKEBudgetTerms.AdvectionTerm-Tuple{NonhydrostaticModel}"><code>Oceanostics.TKEBudgetTerms.AdvectionTerm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdvectionTerm(model; velocities, location)
</code></pre><p>Return a <code>KernelFunctionOperation</code> that computes the advection term, defined as</p><pre><code class="nohighlight hljs">ADV = uᵢ∂ⱼ(uᵢuⱼ)</code></pre><p>By default, the buoyancy production will be calculated using the resolved <code>velocities</code> and users cab use the keyword <code>velocities</code> to modify that behavior:</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size = (1, 1, 4), extent = (1,1,1));

julia&gt; model = NonhydrostaticModel(grid=grid);

julia&gt; using Oceanostics.TKEBudgetTerms: BuoyancyProductionTerm

julia&gt; using Oceanostics.TKEBudgetTerms: AdvectionTerm

julia&gt; ADV = AdvectionTerm(model)
KernelFunctionOperation at (Center, Center, Center)
├── grid: 1×1×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×3 halo
├── kernel_function: uᵢ∂ⱼuⱼuᵢᶜᶜᶜ (generic function with 1 method)
└── arguments: (&quot;(u=1×1×4 Field{Face, Center, Center} on RectilinearGrid on CPU, v=1×1×4 Field{Center, Face, Center} on RectilinearGrid on CPU, w=1×1×5 Field{Center, Center, Face} on RectilinearGrid on CPU)&quot;, &quot;Centered(order=2)&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TKEBudgetTerms.jl#L156-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.BuoyancyProductionTerm-Tuple{NonhydrostaticModel}" href="#Oceanostics.TKEBudgetTerms.BuoyancyProductionTerm-Tuple{NonhydrostaticModel}"><code>Oceanostics.TKEBudgetTerms.BuoyancyProductionTerm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BuoyancyProductionTerm(model; velocities, tracers, location)
</code></pre><p>Return a <code>KernelFunctionOperation</code> that computes the buoyancy production term, defined as</p><pre><code class="nohighlight hljs">BP = uᵢbᵢ</code></pre><p>where bᵢ is the component of the buoyancy acceleration in the <code>i</code>-th direction (which is zero for x and y, except when <code>gravity_unit_vector</code> isn&#39;t aligned with the grid&#39;s z-direction) and all three components of <code>i=1,2,3</code> are added up.</p><p>By default, the buoyancy production will be calculated using the resolved <code>velocities</code> and <code>tracers</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size = (1, 1, 4), extent = (1,1,1));

julia&gt; model = NonhydrostaticModel(grid=grid, buoyancy=BuoyancyTracer(), tracers=:b);

julia&gt; using Oceanostics.TKEBudgetTerms: BuoyancyProductionTerm

julia&gt; wb = BuoyancyProductionTerm(model)
KernelFunctionOperation at (Center, Center, Center)
├── grid: 1×1×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×3 halo
├── kernel_function: uᵢbᵢᶜᶜᶜ (generic function with 1 method)
└── arguments: (&quot;(u=1×1×4 Field{Face, Center, Center} on RectilinearGrid on CPU, v=1×1×4 Field{Center, Face, Center} on RectilinearGrid on CPU, w=1×1×5 Field{Center, Center, Face} on RectilinearGrid on CPU)&quot;, &quot;BuoyancyTracer with ĝ = NegativeZDirection()&quot;, &quot;(b=1×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU,)&quot;)</code></pre><p>If we want to calculate only the <em>turbulent</em> buoyancy production rate, we can do so by passing turbulent perturbations to the <code>velocities</code> and/or <code>tracers</code> options):</p><pre><code class="language-julia-repl hljs">julia&gt; w′ = Field(model.velocities.w - Field(Average(model.velocities.w)));

julia&gt; b′ = Field(model.tracers.b - Field(Average(model.tracers.b)));

julia&gt; w′b′ = BuoyancyProductionTerm(model, velocities=(u=model.velocities.u, v=model.velocities.v, w=w′), tracers=(b=b′,))
KernelFunctionOperation at (Center, Center, Center)
├── grid: 1×1×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×3 halo
├── kernel_function: uᵢbᵢᶜᶜᶜ (generic function with 1 method)
└── arguments: (&quot;(u=1×1×4 Field{Face, Center, Center} on RectilinearGrid on CPU, v=1×1×4 Field{Center, Face, Center} on RectilinearGrid on CPU, w=1×1×5 Field{Center, Center, Face} on RectilinearGrid on CPU)&quot;, &quot;BuoyancyTracer with ĝ = NegativeZDirection()&quot;, &quot;(b=1×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU,)&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TKEBudgetTerms.jl#L423-L467">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.IsotropicKineticEnergyDissipationRate-Tuple{Any}" href="#Oceanostics.TKEBudgetTerms.IsotropicKineticEnergyDissipationRate-Tuple{Any}"><code>Oceanostics.TKEBudgetTerms.IsotropicKineticEnergyDissipationRate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IsotropicKineticEnergyDissipationRate(
    model;
    U,
    V,
    W,
    location
)
</code></pre><p>Calculate the Viscous Dissipation Rate, defined as</p><pre><code class="nohighlight hljs">ε = 2 ν SᵢⱼSᵢⱼ,</code></pre><p>where Sᵢⱼ is the strain rate tensor, for a fluid with an isotropic turbulence closure (i.e., a  turbulence closure where ν (eddy or not) is the same for all directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TKEBudgetTerms.jl#L206-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.KineticEnergy-NTuple{4, Any}" href="#Oceanostics.TKEBudgetTerms.KineticEnergy-NTuple{4, Any}"><code>Oceanostics.TKEBudgetTerms.KineticEnergy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KineticEnergy(model, u, v, w; location, kwargs...)
</code></pre><p>Calculate the kinetic energy of <code>model</code> manually specifying <code>u</code>, <code>v</code> and <code>w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TKEBudgetTerms.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.KineticEnergy-Tuple{Any}" href="#Oceanostics.TKEBudgetTerms.KineticEnergy-Tuple{Any}"><code>Oceanostics.TKEBudgetTerms.KineticEnergy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KineticEnergy(model; kwargs...)
</code></pre><p>Calculate the kinetic energy of <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TKEBudgetTerms.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.KineticEnergyDissipationRate-Tuple{Any}" href="#Oceanostics.TKEBudgetTerms.KineticEnergyDissipationRate-Tuple{Any}"><code>Oceanostics.TKEBudgetTerms.KineticEnergyDissipationRate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KineticEnergyDissipationRate(model; U, V, W, location)
</code></pre><p>Calculate the Kinetic Energy Dissipation Rate, defined as</p><pre><code class="nohighlight hljs">ε = ν (∂uᵢ/∂xⱼ) (∂uᵢ/∂xⱼ)
ε = ∂ⱼuᵢ ⋅ Fᵢⱼ</code></pre><p>where ∂ⱼuᵢ is the velocity gradient tensor and Fᵢⱼ is the stress tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TKEBudgetTerms.jl#L261-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.KineticEnergyForcingTerm-Tuple{NonhydrostaticModel}" href="#Oceanostics.TKEBudgetTerms.KineticEnergyForcingTerm-Tuple{NonhydrostaticModel}"><code>Oceanostics.TKEBudgetTerms.KineticEnergyForcingTerm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KineticEnergyForcingTerm(model; location)
</code></pre><p>Return a <code>KernelFunctionOperation</code> that computes the forcing term of the KE prognostic equation:</p><pre><code class="nohighlight hljs">    FORC = uᵢFᵤᵢ</code></pre><p>where <code>uᵢ</code> are the velocity components and <code>Fᵤᵢ</code> is the forcing term(s) in the <code>uᵢ</code> prognostic equation (i.e. the forcing for <code>uᵢ</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TKEBudgetTerms.jl#L339-L350">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.KineticEnergyStressTerm-Tuple{Any}" href="#Oceanostics.TKEBudgetTerms.KineticEnergyStressTerm-Tuple{Any}"><code>Oceanostics.TKEBudgetTerms.KineticEnergyStressTerm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KineticEnergyStressTerm(model; location)
</code></pre><p>Return a <code>KernelFunctionOperation</code> that computes the diffusive term of the KE prognostic equation:</p><pre><code class="nohighlight hljs">    DIFF = uᵢ∂ⱼτᵢⱼ</code></pre><p>where <code>uᵢ</code> are the velocity components and <code>τᵢⱼ</code> is the diffusive flux of <code>i</code> momentum in the  <code>j</code>-th direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TKEBudgetTerms.jl#L299-L310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.KineticEnergyTendency-Tuple{NonhydrostaticModel}" href="#Oceanostics.TKEBudgetTerms.KineticEnergyTendency-Tuple{NonhydrostaticModel}"><code>Oceanostics.TKEBudgetTerms.KineticEnergyTendency</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KineticEnergyTendency(model; location)
</code></pre><p>Return a <code>KernelFunctionOperation</code> that computes the tendency uᵢGᵢ of the KE, excluding the nonhydrostatic pressure contribution:</p><pre><code class="nohighlight hljs">KET = ½∂ₜuᵢ² = uᵢGᵢ - uᵢ∂ᵢpₙₕₛ</code></pre><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size = (1, 1, 4), extent = (1,1,1));

julia&gt; model = NonhydrostaticModel(; grid);

julia&gt; using Oceanostics.TKEBudgetTerms: KineticEnergyTendency

julia&gt; ke_tendency = KineticEnergyTendency(model)
KernelFunctionOperation at (Center, Center, Center)
├── grid: 1×1×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×3 halo
├── kernel_function: uᵢGᵢᶜᶜᶜ (generic function with 1 method)
└── arguments: (&quot;Centered(order=2)&quot;, &quot;Nothing&quot;, &quot;Nothing&quot;, &quot;Nothing&quot;, &quot;FluxBoundaryCondition: Nothing&quot;, &quot;FluxBoundaryCondition: Nothing&quot;, &quot;FluxBoundaryCondition: Nothing&quot;, &quot;Nothing&quot;, &quot;(velocities=(u=ZeroField{Int64}, v=ZeroField{Int64}, w=ZeroField{Int64}), tracers=NamedTuple())&quot;, &quot;(u=1×1×4 Field{Face, Center, Center} on RectilinearGrid on CPU, v=1×1×4 Field{Center, Face, Center} on RectilinearGrid on CPU, w=1×1×5 Field{Center, Center, Face} on RectilinearGrid on CPU)&quot;, &quot;NamedTuple()&quot;, &quot;NamedTuple()&quot;, &quot;Nothing&quot;, &quot;(u=zeroforcing (generic function with 1 method), v=zeroforcing (generic function with 1 method), w=zeroforcing (generic function with 1 method))&quot;, &quot;Nothing&quot;, &quot;Clock{Float64, Float64}(time=0 seconds, iteration=0, last_Δt=Inf days)&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TKEBudgetTerms.jl#L102-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.PressureRedistributionTerm-Tuple{NonhydrostaticModel}" href="#Oceanostics.TKEBudgetTerms.PressureRedistributionTerm-Tuple{NonhydrostaticModel}"><code>Oceanostics.TKEBudgetTerms.PressureRedistributionTerm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PressureRedistributionTerm(
    model;
    velocities,
    pressure,
    location
)
</code></pre><p>Return a <code>KernelFunctionOperation</code> that computes the pressure redistribution term:</p><pre><code class="nohighlight hljs">PR = uᵢ∂ᵢp</code></pre><p>where <code>p</code> is the pressure. By default <code>p</code> is taken to be the total pressure (nonhydrostatic + hydrostatic):</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size = (1, 1, 4), extent = (1,1,1));

julia&gt; model = NonhydrostaticModel(grid=grid);

julia&gt; using Oceanostics.TKEBudgetTerms: PressureRedistributionTerm

julia&gt; ∇u⃗p = PressureRedistributionTerm(model)
KernelFunctionOperation at (Center, Center, Center)
├── grid: 1×1×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×3 halo
├── kernel_function: uᵢ∂ᵢpᶜᶜᶜ (generic function with 1 method)
└── arguments: (&quot;(u=1×1×4 Field{Face, Center, Center} on RectilinearGrid on CPU, v=1×1×4 Field{Center, Face, Center} on RectilinearGrid on CPU, w=1×1×5 Field{Center, Center, Face} on RectilinearGrid on CPU)&quot;, &quot;1×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU&quot;)</code></pre><p>We can also pass <code>velocities</code> and <code>pressure</code> keywords to perform more specific calculations. The example below illustrates calculation of the nonhydrostatic contribution to the pressure redistrubution term:</p><pre><code class="language-julia-repl hljs">julia&gt; ∇u⃗pNHS = PressureRedistributionTerm(model, pressure=model.pressures.pNHS)
KernelFunctionOperation at (Center, Center, Center)
├── grid: 1×1×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×3 halo
├── kernel_function: uᵢ∂ᵢpᶜᶜᶜ (generic function with 1 method)
└── arguments: (&quot;(u=1×1×4 Field{Face, Center, Center} on RectilinearGrid on CPU, v=1×1×4 Field{Center, Face, Center} on RectilinearGrid on CPU, w=1×1×5 Field{Center, Center, Face} on RectilinearGrid on CPU)&quot;, &quot;1×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TKEBudgetTerms.jl#L370-L406">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.TurbulentKineticEnergy-NTuple{4, Any}" href="#Oceanostics.TKEBudgetTerms.TurbulentKineticEnergy-NTuple{4, Any}"><code>Oceanostics.TKEBudgetTerms.TurbulentKineticEnergy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TurbulentKineticEnergy(model, u, v, w; U, V, W, location)
</code></pre><p>Calculate the turbulent kinetic energy of <code>model</code> manually specifying <code>u</code>, <code>v</code>, <code>w</code> and optionally background velocities <code>U</code>, <code>V</code> and <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TKEBudgetTerms.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.TurbulentKineticEnergy-Tuple{Any}" href="#Oceanostics.TKEBudgetTerms.TurbulentKineticEnergy-Tuple{Any}"><code>Oceanostics.TKEBudgetTerms.TurbulentKineticEnergy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TurbulentKineticEnergy(model; kwargs...)
</code></pre><p>Calculate the turbulent kinetic energy of <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TKEBudgetTerms.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.XShearProductionRate-NTuple{7, Any}" href="#Oceanostics.TKEBudgetTerms.XShearProductionRate-NTuple{7, Any}"><code>Oceanostics.TKEBudgetTerms.XShearProductionRate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">XShearProductionRate(model, u, v, w, U, V, W; location)
</code></pre><p>Calculate the shear production rate in the <code>model</code>&#39;s <code>x</code> direction, considering velocities <code>u</code>, <code>v</code>, <code>w</code> and background (or average) velocities <code>U</code>, <code>V</code> and <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TKEBudgetTerms.jl#L493-L498">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.XShearProductionRate-Tuple{Any}" href="#Oceanostics.TKEBudgetTerms.XShearProductionRate-Tuple{Any}"><code>Oceanostics.TKEBudgetTerms.XShearProductionRate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">XShearProductionRate(model; U, V, W, kwargs...)
</code></pre><p>Calculate the shear production rate in the <code>model</code>&#39;s <code>x</code> direction. At least one of the mean  velocities <code>U</code>, <code>V</code> and <code>W</code> must be specified otherwise the output will be zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TKEBudgetTerms.jl#L505-L510">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.YShearProductionRate-NTuple{7, Any}" href="#Oceanostics.TKEBudgetTerms.YShearProductionRate-NTuple{7, Any}"><code>Oceanostics.TKEBudgetTerms.YShearProductionRate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">YShearProductionRate(model, u, v, w, U, V, W; location)
</code></pre><p>Calculate the shear production rate in the <code>model</code>&#39;s <code>y</code> direction, considering velocities <code>u</code>, <code>v</code>, <code>w</code> and background (or average) velocities <code>U</code>, <code>V</code> and <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TKEBudgetTerms.jl#L535-L540">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.YShearProductionRate-Tuple{Any}" href="#Oceanostics.TKEBudgetTerms.YShearProductionRate-Tuple{Any}"><code>Oceanostics.TKEBudgetTerms.YShearProductionRate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">YShearProductionRate(model; U, V, W, kwargs...)
</code></pre><p>Calculate the shear production rate in the <code>model</code>&#39;s <code>y</code> direction. At least one of the mean  velocities <code>U</code>, <code>V</code> and <code>W</code> must be specified otherwise the output will be zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TKEBudgetTerms.jl#L547-L552">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.ZShearProductionRate-NTuple{7, Any}" href="#Oceanostics.TKEBudgetTerms.ZShearProductionRate-NTuple{7, Any}"><code>Oceanostics.TKEBudgetTerms.ZShearProductionRate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ZShearProductionRate(model, u, v, w, U, V, W; location)
</code></pre><p>Calculate the shear production rate in the <code>model</code>&#39;s <code>z</code> direction, considering velocities <code>u</code>, <code>v</code>, <code>w</code> and background (or average) velocities <code>U</code>, <code>V</code> and <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TKEBudgetTerms.jl#L577-L582">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TKEBudgetTerms.ZShearProductionRate-Tuple{Any}" href="#Oceanostics.TKEBudgetTerms.ZShearProductionRate-Tuple{Any}"><code>Oceanostics.TKEBudgetTerms.ZShearProductionRate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ZShearProductionRate(model; U, V, W, kwargs...)
</code></pre><p>Calculate the shear production rate in the <code>model</code>&#39;s <code>z</code> direction. At least one of the mean  velocities <code>U</code>, <code>V</code> and <code>W</code> must be specified otherwise the output will be zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TKEBudgetTerms.jl#L589-L594">source</a></section></article><h2 id="Oceanostics.TracerVarianceBudgetTerms"><a class="docs-heading-anchor" href="#Oceanostics.TracerVarianceBudgetTerms">Oceanostics.TracerVarianceBudgetTerms</a><a id="Oceanostics.TracerVarianceBudgetTerms-1"></a><a class="docs-heading-anchor-permalink" href="#Oceanostics.TracerVarianceBudgetTerms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TracerVarianceBudgetTerms.TracerVarianceDiffusiveTerm-Tuple{Any, Any}" href="#Oceanostics.TracerVarianceBudgetTerms.TracerVarianceDiffusiveTerm-Tuple{Any, Any}"><code>Oceanostics.TracerVarianceBudgetTerms.TracerVarianceDiffusiveTerm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TracerVarianceDiffusiveTerm(model, tracer_name; location)
</code></pre><p>Return a <code>KernelFunctionOperation</code> that computes the diffusive term of the tracer variance prognostic equation using Oceananigans&#39; diffusive tracer flux divergence kernel:</p><pre><code class="nohighlight hljs">    DIFF = 2 c ∂ⱼFⱼ</code></pre><p>where <code>c</code> is the tracer, and <code>Fⱼ</code> is the tracer&#39;s diffusive flux in the <code>j</code>-th direction.</p><pre><code class="language-julia hljs">grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1))
model = NonhydrostaticModel(grid=grid, tracers=:b, closure=SmagorinskyLilly())

DIFF = TracerVarianceDiffusiveTerm(model, :b)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TracerVarianceBudgetTerms.jl#L87-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TracerVarianceBudgetTerms.TracerVarianceDissipationRate-Tuple{Any, Any}" href="#Oceanostics.TracerVarianceBudgetTerms.TracerVarianceDissipationRate-Tuple{Any, Any}"><code>Oceanostics.TracerVarianceBudgetTerms.TracerVarianceDissipationRate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TracerVarianceDissipationRate(
    model,
    tracer_name;
    tracer,
    location
)
</code></pre><p>Return a <code>KernelFunctionOperation</code> that computes the isotropic variance dissipation rate for <code>tracer_name</code> in <code>model.tracers</code>. The isotropic variance dissipation rate is defined as </p><pre><code class="nohighlight hljs">    χ = 2 ∂ⱼc ⋅ Fⱼ</code></pre><p>where <code>Fⱼ</code> is the diffusive flux of <code>c</code> in the <code>j</code>-th direction and <code>∂ⱼ</code> is the gradient operator. <code>χ</code> is implemented in its conservative formulation based on the equation above. </p><p>Note that often <code>χ</code> is written as <code>χ = 2κ (∇c ⋅ ∇c)</code>, which is the special case for Fickian diffusion (<code>κ</code> is the tracer diffusivity).</p><p>Here <code>tracer_name</code> is needed even when passing <code>tracer</code> in order to get the appropriate <code>tracer_index</code>. When passing <code>tracer</code>, this function should be used as</p><pre><code class="language-julia hljs">grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1))
model = NonhydrostaticModel(grid=grid, tracers=:b, closure=SmagorinskyLilly())

b̄ = Field(Average(model.tracers.b, dims=(1,2)))
b′ = model.tracers.b - b̄

χb = TracerVarianceDissipationRate(model, :b, tracer=b′)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TracerVarianceBudgetTerms.jl#L139-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.TracerVarianceBudgetTerms.TracerVarianceTendency-Tuple{NonhydrostaticModel, Any}" href="#Oceanostics.TracerVarianceBudgetTerms.TracerVarianceTendency-Tuple{NonhydrostaticModel, Any}"><code>Oceanostics.TracerVarianceBudgetTerms.TracerVarianceTendency</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TracerVarianceTendency(model, tracer_name; location)
</code></pre><p>Return a <code>KernelFunctionOperation</code> that computes the tracer variance tendency:</p><pre><code class="nohighlight hljs">TEND = 2 c ∂ₜc</code></pre><p>where <code>c</code> is the tracer and <code>∂ₜc</code> is the tracer tendency (computed using Oceananigans&#39; tracer tendency kernel).</p><pre><code class="language-julia hljs">grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1))
model = NonhydrostaticModel(grid=grid, tracers=:b, closure=SmagorinskyLilly())

DIFF = TracerVarianceTendency(model, :b)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/TracerVarianceBudgetTerms.jl#L39-L55">source</a></section></article><h2 id="Oceanostics.FlowDiagnostics"><a class="docs-heading-anchor" href="#Oceanostics.FlowDiagnostics">Oceanostics.FlowDiagnostics</a><a id="Oceanostics.FlowDiagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Oceanostics.FlowDiagnostics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.DirectionalErtelPotentialVorticity-Tuple{Any, Any}" href="#Oceanostics.FlowDiagnostics.DirectionalErtelPotentialVorticity-Tuple{Any, Any}"><code>Oceanostics.FlowDiagnostics.DirectionalErtelPotentialVorticity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DirectionalErtelPotentialVorticity(
    model,
    direction;
    location
)
</code></pre><p>Calculate the contribution from a given <code>direction</code> to the Ertel Potential Vorticity basde on a <code>model</code> and a <code>direction</code>. The Ertel Potential Vorticity is defined as</p><pre><code class="nohighlight hljs">EPV = ωₜₒₜ ⋅ ∇b</code></pre><p>where ωₜₒₜ is the total (relative + planetary) vorticity vector, <code>b</code> is the buoyancy and ∇ is the gradient operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/FlowDiagnostics.jl#L348-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.ErtelPotentialVorticity-Tuple{Any}" href="#Oceanostics.FlowDiagnostics.ErtelPotentialVorticity-Tuple{Any}"><code>Oceanostics.FlowDiagnostics.ErtelPotentialVorticity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ErtelPotentialVorticity(model; location, add_background)
</code></pre><p>Calculate the Ertel Potential Vorticty for <code>model</code>, where the characteristics of the Coriolis rotation are taken from <code>model.coriolis</code>. The Ertel Potential Vorticity is defined as</p><pre><code class="nohighlight hljs">EPV = ωₜₒₜ ⋅ ∇b</code></pre><p>where ωₜₒₜ is the total (relative + planetary) vorticity vector, <code>b</code> is the buoyancy and ∇ is the gradient operator.</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(topology = (Flat, Flat, Bounded), size = 4, extent = 1);

julia&gt; N² = 1e-6;

julia&gt; b_bcs = FieldBoundaryConditions(top=GradientBoundaryCondition(N²));

julia&gt; model = NonhydrostaticModel(; grid, coriolis=FPlane(1e-4), buoyancy=BuoyancyTracer(), tracers=:b, boundary_conditions=(; b=b_bcs));

julia&gt; stratification(z) = N² * z;

julia&gt; set!(model, b=stratification)

julia&gt; using Oceanostics: ErtelPotentialVorticity

julia&gt; EPV = ErtelPotentialVorticity(model)
KernelFunctionOperation at (Face, Face, Face)
├── grid: 1×1×4 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo
├── kernel_function: ertel_potential_vorticity_fff (generic function with 1 method)
└── arguments: (&quot;1×1×4 Field{Face, Center, Center} on RectilinearGrid on CPU&quot;, &quot;1×1×4 Field{Center, Face, Center} on RectilinearGrid on CPU&quot;, &quot;1×1×5 Field{Center, Center, Face} on RectilinearGrid on CPU&quot;, &quot;1×1×4 Field{Center, Center, Center} on RectilinearGrid on CPU&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0.0001&quot;)

julia&gt; interior(compute!(Field(EPV)))
1×1×5 view(::Array{Float64, 3}, 1:1, 1:1, 4:8) with eltype Float64:
[:, :, 1] =
 0.0

[:, :, 2] =
 1.0000000000000002e-10

[:, :, 3] =
 9.999999999999998e-11

[:, :, 4] =
 1.0000000000000002e-10

[:, :, 5] =
 1.0e-10</code></pre><p>Note that EPV values are correctly calculated both in the interior and the boundaries. In the interior and top boundary, EPV = f×N² = 10⁻¹⁰, while EPV = 0 at the bottom boundary since ∂b/∂z is zero there.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/FlowDiagnostics.jl#L225-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.QVelocityGradientTensorInvariant-Tuple{Any}" href="#Oceanostics.FlowDiagnostics.QVelocityGradientTensorInvariant-Tuple{Any}"><code>Oceanostics.FlowDiagnostics.QVelocityGradientTensorInvariant</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QVelocityGradientTensorInvariant(model; location)
</code></pre><p>Calculate the value of the <code>Q</code> velocity gradient tensor invariant. This is usually just called <code>Q</code> and it is generally used for identifying and visualizing vortices in fluid flow.</p><p>The definition and nomenclature comes from the equation for the eigenvalues <code>λ</code> of the velocity gradient tensor <code>∂ⱼuᵢ</code>:</p><pre><code class="nohighlight hljs">    λ³ + P λ² + Q λ + T = 0</code></pre><p>from where <code>Q</code> is defined as</p><pre><code class="nohighlight hljs">    Q = ½ ( ΩᵢⱼΩᵢⱼ - SᵢⱼSᵢⱼ)</code></pre><p>and where <code>Sᵢⱼ= ½(∂ⱼuᵢ + ∂ᵢuⱼ)</code> and <code>Ωᵢⱼ= ½(∂ⱼuᵢ - ∂ᵢuⱼ)</code>. More info about it can be found in doi:10.1063/1.5124245.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/FlowDiagnostics.jl#L479-L498">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.RichardsonNumber-Tuple{Any}" href="#Oceanostics.FlowDiagnostics.RichardsonNumber-Tuple{Any}"><code>Oceanostics.FlowDiagnostics.RichardsonNumber</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RichardsonNumber(model; location, add_background)
</code></pre><p>Calculate the Richardson Number as</p><pre><code class="nohighlight hljs">    Ri = (∂b/∂z) / (|∂u⃗ₕ/∂z|²)</code></pre><p>where <code>z</code> is the true vertical direction (ie anti-parallel to gravity).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/FlowDiagnostics.jl#L56-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.RossbyNumber-Tuple{Any}" href="#Oceanostics.FlowDiagnostics.RossbyNumber-Tuple{Any}"><code>Oceanostics.FlowDiagnostics.RossbyNumber</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RossbyNumber(
    model;
    location,
    add_background,
    dWdy_bg,
    dVdz_bg,
    dUdz_bg,
    dWdx_bg,
    dUdy_bg,
    dVdx_bg
)
</code></pre><p>Calculate the Rossby number using the vorticity in the rotation axis direction according to <code>model.coriolis</code>. Rossby number is defined as</p><pre><code class="nohighlight hljs">    Ro = ωᶻ / f</code></pre><p>where ωᶻ is the vorticity in the Coriolis axis of rotation and <code>f</code> is the Coriolis rotation frequency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/FlowDiagnostics.jl#L114-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.StrainRateTensorModulus-Tuple{Any}" href="#Oceanostics.FlowDiagnostics.StrainRateTensorModulus-Tuple{Any}"><code>Oceanostics.FlowDiagnostics.StrainRateTensorModulus</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StrainRateTensorModulus(model; location)
</code></pre><p>Calculate the modulus (absolute value) of the strain rate tensor <code>S</code>, which is defined as the symmetric part of the velocity gradient tensor:</p><pre><code class="nohighlight hljs">    Sᵢⱼ = ½(∂ⱼuᵢ + ∂ᵢuⱼ)</code></pre><p>Its modulus is then defined (using Einstein summation notation) as</p><pre><code class="nohighlight hljs">    || Sᵢⱼ || = √( Sᵢⱼ Sᵢⱼ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/FlowDiagnostics.jl#L416-L430">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.ThermalWindPotentialVorticity-Tuple{Any}" href="#Oceanostics.FlowDiagnostics.ThermalWindPotentialVorticity-Tuple{Any}"><code>Oceanostics.FlowDiagnostics.ThermalWindPotentialVorticity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ThermalWindPotentialVorticity(model; f, location)
</code></pre><p>Calculate the Potential Vorticty assuming thermal wind balance for <code>model</code>, where the characteristics of the Coriolis rotation are taken from <code>model.coriolis</code>. The Potential Vorticity in this case is defined as</p><pre><code class="nohighlight hljs">    TWPV = (f + ωᶻ) ∂b/∂z - f ((∂U/∂z)² + (∂V/∂z)²)</code></pre><p>where <code>f</code> is the Coriolis frequency, <code>ωᶻ</code> is the relative vorticity in the <code>z</code> direction, <code>b</code> is the buoyancy, and <code>∂U/∂z</code> and <code>∂V/∂z</code> comprise the thermal wind shear.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/FlowDiagnostics.jl#L182-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.FlowDiagnostics.VorticityTensorModulus-Tuple{Any}" href="#Oceanostics.FlowDiagnostics.VorticityTensorModulus-Tuple{Any}"><code>Oceanostics.FlowDiagnostics.VorticityTensorModulus</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VorticityTensorModulus(model; location)
</code></pre><p>Calculate the modulus (absolute value) of the vorticity tensor <code>Ω</code>, which is defined as the antisymmetric part of the velocity gradient tensor:</p><pre><code class="nohighlight hljs">    Ωᵢⱼ = ½(∂ⱼuᵢ - ∂ᵢuⱼ)</code></pre><p>Its modulus is then defined (using Einstein summation notation) as</p><pre><code class="nohighlight hljs">    || Ωᵢⱼ || = √( Ωᵢⱼ Ωᵢⱼ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/FlowDiagnostics.jl#L451-L465">source</a></section></article><h2 id="Oceanostics.PotentialEnergyEquationTerms"><a class="docs-heading-anchor" href="#Oceanostics.PotentialEnergyEquationTerms">Oceanostics.PotentialEnergyEquationTerms</a><a id="Oceanostics.PotentialEnergyEquationTerms-1"></a><a class="docs-heading-anchor-permalink" href="#Oceanostics.PotentialEnergyEquationTerms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Oceanostics.PotentialEnergyEquationTerms.PotentialEnergy-Tuple{Any}" href="#Oceanostics.PotentialEnergyEquationTerms.PotentialEnergy-Tuple{Any}"><code>Oceanostics.PotentialEnergyEquationTerms.PotentialEnergy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PotentialEnergy(model; location, geopotential_height)
</code></pre><p>Return a <code>KernelFunctionOperation</code> to compute the <code>PotentialEnergy</code> per unit volume,</p><p class="math-container">\[Eₚ = \frac{gρ}{ρ₀}z = -bz\]</p><p>at each grid <code>location</code> in <code>model</code>. <code>PotentialEnergy</code> is defined for both <code>BuoyancyTracer</code> and <code>SeawaterBuoyancy</code>. See the relevant Oceananigans.jl documentation on <a href="https://clima.github.io/OceananigansDocumentation/dev/model_setup/buoyancy_and_equation_of_state/">buoyancy models</a> for more information about available options.</p><p>The optional keyword argument <code>geopotential_height</code> is only used if ones wishes to calculate <code>Eₚ</code> with a potential density referenced to <code>geopotential_height</code>, rather than in-situ density, when using a <code>BoussinesqEquationOfState</code>.</p><p><strong>Example</strong></p><p>Usage with a <code>BuoyancyTracer</code> buoyacny model</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans

julia&gt; using Oceanostics.PotentialEnergyEquationTerms: PotentialEnergy

julia&gt; grid = RectilinearGrid(size=100, z=(-1000, 0), topology=(Flat, Flat, Bounded))
1×1×100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo
├── Flat x
├── Flat y
└── Bounded  z ∈ [-1000.0, 0.0] regularly spaced with Δz=10.0

julia&gt; model = NonhydrostaticModel(; grid, buoyancy=BuoyancyTracer(), tracers=(:b,))
NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)
├── grid: 1×1×100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo
├── timestepper: RungeKutta3TimeStepper
├── advection scheme: Centered(order=2)
├── tracers: b
├── closure: Nothing
├── buoyancy: BuoyancyTracer with ĝ = NegativeZDirection()
└── coriolis: Nothing

julia&gt; PotentialEnergy(model)
KernelFunctionOperation at (Center, Center, Center)
├── grid: 1×1×100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo
├── kernel_function: minus_bz_ccc (generic function with 3 methods)
└── arguments: (&quot;1×1×100 Field{Center, Center, Center} on RectilinearGrid on CPU&quot;,)</code></pre><p>The default behaviour of <code>PotentialEnergy</code> uses the <em>in-situ density</em> in the calculation when the equation of state is a <code>BoussinesqEquationOfState</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, SeawaterPolynomials.TEOS10

julia&gt; using Oceanostics.PotentialEnergyEquationTerms: PotentialEnergy

julia&gt; grid = RectilinearGrid(size=100, z=(-1000, 0), topology=(Flat, Flat, Bounded))
1×1×100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo
├── Flat x
├── Flat y
└── Bounded  z ∈ [-1000.0, 0.0] regularly spaced with Δz=10.0

julia&gt; tracers = (:T, :S)
(:T, :S)

julia&gt; eos = TEOS10EquationOfState()
BoussinesqEquationOfState{Float64}:
    ├── seawater_polynomial: TEOS10SeawaterPolynomial{Float64}
    └── reference_density: 1020.0

julia&gt; buoyancy = SeawaterBuoyancy(equation_of_state=eos)
SeawaterBuoyancy{Float64}:
├── gravitational_acceleration: 9.80665
└── equation_of_state: BoussinesqEquationOfState{Float64}

julia&gt; model = NonhydrostaticModel(; grid, buoyancy, tracers)
NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)
├── grid: 1×1×100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo
├── timestepper: RungeKutta3TimeStepper
├── advection scheme: Centered(order=2)
├── tracers: (T, S)
├── closure: Nothing
├── buoyancy: SeawaterBuoyancy with g=9.80665 and BoussinesqEquationOfState{Float64} with ĝ = NegativeZDirection()
└── coriolis: Nothing

julia&gt; PotentialEnergy(model)
KernelFunctionOperation at (Center, Center, Center)
├── grid: 1×1×100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo
├── kernel_function: minus_bz_ccc (generic function with 3 methods)
└── arguments: (&quot;KernelFunctionOperation at (Center, Center, Center)&quot;, &quot;(g=9.80665, ρ₀=1020.0)&quot;)</code></pre><p>To use a reference density set a constant value for the keyword argument <code>geopotential_height</code> and pass this the function. For example,</p><pre><code class="language-julia-repl hljs">julia&gt; using Oceananigans, SeawaterPolynomials.TEOS10;

julia&gt; using Oceanostics.PotentialEnergyEquationTerms: PotentialEnergy;

julia&gt; grid = RectilinearGrid(size=100, z=(-1000, 0), topology=(Flat, Flat, Bounded));

julia&gt; tracers = (:T, :S);

julia&gt; eos = TEOS10EquationOfState();

julia&gt; buoyancy = SeawaterBuoyancy(equation_of_state=eos);

julia&gt; model = NonhydrostaticModel(; grid, buoyancy, tracers);

julia&gt; geopotential_height = 0; # density variable will be σ₀

julia&gt; PotentialEnergy(model)
KernelFunctionOperation at (Center, Center, Center)
├── grid: 1×1×100 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo
├── kernel_function: minus_bz_ccc (generic function with 3 methods)
└── arguments: (&quot;KernelFunctionOperation at (Center, Center, Center)&quot;, &quot;(g=9.80665, ρ₀=1020.0)&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomchor/Oceanostics.jl/blob/674bc94b769bc4a25e03d5dafc948270fc3ab43a/src/PotentialEnergyEquationTerms.jl#L29-L145">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../generated/tilted_bottom_boundary_layer/">« Tilted bottom boundary layer</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 15 November 2024 16:50">Friday 15 November 2024</span>. Using Julia version 1.10.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
